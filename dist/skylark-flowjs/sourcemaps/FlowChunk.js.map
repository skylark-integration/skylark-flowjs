{"version":3,"sources":["FlowChunk.js"],"names":["define","langx","flowjs","utils","each","evalOpts","extend","FlowChunk","flowObj","fileObj","offset","this","tested","retries","pendingRetry","preprocessState","readState","loaded","total","chunkSize","opts","startByte","computeEndByte","endByte","Math","min","size","forceChunkSize","xhr","$","event","args","Array","prototype","slice","call","arguments","unshift","chunkEvent","apply","progressHandler","lengthComputable","testHandler","status","message","uploadNextChunk","paused","send","doneHandler","data","abort","retryInterval","chunkRetryInterval","setTimeout","getParams","flowChunkNumber","flowChunkSize","flowCurrentChunkSize","flowTotalSize","flowIdentifier","uniqueIdentifier","flowFilename","name","flowRelativePath","relativePath","flowTotalChunks","chunks","length","getTarget","target","params","indexOf","join","test","XMLHttpRequest","addEventListener","testMethod","prepareXhrRequest","preprocessFinished","readFinished","bytes","preprocess","read","readFileFn","file","type","testChunks","upload","uploadMethod","method","isTest","readyState","successStatuses","permanentErrors","maxChunkRetries","responseText","progress","s","sizeUploaded","paramsMethod","blob","query","v","k","push","encodeURIComponent","FormData","append","fileParameterName","open","withCredentials","headers","setRequestHeader"],"mappings":"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","file":"../FlowChunk.js","sourcesContent":["define([\r\n  \"skylark-langx/langx\",\r\n  \"./flowjs\",\r\n \"./utils\"\r\n ],function(langx,flowjs,utils){\r\n  'use strict';\r\n\r\n  var each = utils.each,\r\n  \t  evalOpts = utils.evalOpts,\r\n  \t  extend = utils.extend;\r\n\r\n  /**\r\n   * Class for storing a single chunk\r\n   * @name FlowChunk\r\n   * @param {Flow} flowObj\r\n   * @param {FlowFile} fileObj\r\n   * @param {number} offset\r\n   * @constructor\r\n   */\r\n  function FlowChunk(flowObj, fileObj, offset) {\r\n\r\n    /**\r\n     * Reference to parent flow object\r\n     * @type {Flow}\r\n     */\r\n    this.flowObj = flowObj;\r\n\r\n    /**\r\n     * Reference to parent FlowFile object\r\n     * @type {FlowFile}\r\n     */\r\n    this.fileObj = fileObj;\r\n\r\n    /**\r\n     * File offset\r\n     * @type {number}\r\n     */\r\n    this.offset = offset;\r\n\r\n    /**\r\n     * Indicates if chunk existence was checked on the server\r\n     * @type {boolean}\r\n     */\r\n    this.tested = false;\r\n\r\n    /**\r\n     * Number of retries performed\r\n     * @type {number}\r\n     */\r\n    this.retries = 0;\r\n\r\n    /**\r\n     * Pending retry\r\n     * @type {boolean}\r\n     */\r\n    this.pendingRetry = false;\r\n\r\n    /**\r\n     * Preprocess state\r\n     * @type {number} 0 = unprocessed, 1 = processing, 2 = finished\r\n     */\r\n    this.preprocessState = 0;\r\n\r\n    /**\r\n     * Read state\r\n     * @type {number} 0 = not read, 1 = reading, 2 = finished\r\n     */\r\n    this.readState = 0;\r\n\r\n\r\n    /**\r\n     * Bytes transferred from total request size\r\n     * @type {number}\r\n     */\r\n    this.loaded = 0;\r\n\r\n    /**\r\n     * Total request size\r\n     * @type {number}\r\n     */\r\n    this.total = 0;\r\n\r\n    /**\r\n     * Size of a chunk\r\n     * @type {number}\r\n     */\r\n    this.chunkSize = this.flowObj.opts.chunkSize;\r\n\r\n    /**\r\n     * Chunk start byte in a file\r\n     * @type {number}\r\n     */\r\n    this.startByte = this.offset * this.chunkSize;\r\n\r\n    /**\r\n      * Compute the endbyte in a file\r\n      *\r\n      */\r\n    this.computeEndByte = function() {\r\n      var endByte = Math.min(this.fileObj.size, (this.offset + 1) * this.chunkSize);\r\n      if (this.fileObj.size - endByte < this.chunkSize && !this.flowObj.opts.forceChunkSize) {\r\n        // The last chunk will be bigger than the chunk size,\r\n        // but less than 2 * this.chunkSize\r\n        endByte = this.fileObj.size;\r\n      }\r\n      return endByte;\r\n    }\r\n\r\n    /**\r\n     * Chunk end byte in a file\r\n     * @type {number}\r\n     */\r\n    this.endByte = this.computeEndByte();\r\n\r\n    /**\r\n     * XMLHttpRequest\r\n     * @type {XMLHttpRequest}\r\n     */\r\n    this.xhr = null;\r\n\r\n    var $ = this;\r\n\r\n    /**\r\n     * Send chunk event\r\n     * @param event\r\n     * @param {...} args arguments of a callback\r\n     */\r\n    this.event = function (event, args) {\r\n      args = Array.prototype.slice.call(arguments);\r\n      args.unshift($);\r\n      $.fileObj.chunkEvent.apply($.fileObj, args);\r\n    };\r\n    /**\r\n     * Catch progress event\r\n     * @param {ProgressEvent} event\r\n     */\r\n    this.progressHandler = function(event) {\r\n      if (event.lengthComputable) {\r\n        $.loaded = event.loaded ;\r\n        $.total = event.total;\r\n      }\r\n      $.event('progress', event);\r\n    };\r\n\r\n    /**\r\n     * Catch test event\r\n     * @param {Event} event\r\n     */\r\n    this.testHandler = function(event) {\r\n      var status = $.status(true);\r\n      if (status === 'error') {\r\n        $.event(status, $.message());\r\n        $.flowObj.uploadNextChunk();\r\n      } else if (status === 'success') {\r\n        $.tested = true;\r\n        $.event(status, $.message());\r\n        $.flowObj.uploadNextChunk();\r\n      } else if (!$.fileObj.paused) {\r\n        // Error might be caused by file pause method\r\n        // Chunks does not exist on the server side\r\n        $.tested = true;\r\n        $.send();\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Upload has stopped\r\n     * @param {Event} event\r\n     */\r\n    this.doneHandler = function(event) {\r\n      var status = $.status();\r\n      if (status === 'success' || status === 'error') {\r\n        delete this.data;\r\n        $.event(status, $.message());\r\n        $.flowObj.uploadNextChunk();\r\n      } else {\r\n        $.event('retry', $.message());\r\n        $.pendingRetry = true;\r\n        $.abort();\r\n        $.retries++;\r\n        var retryInterval = $.flowObj.opts.chunkRetryInterval;\r\n        if (retryInterval !== null) {\r\n          setTimeout(function () {\r\n            $.send();\r\n          }, retryInterval);\r\n        } else {\r\n          $.send();\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  FlowChunk.prototype = {\r\n    /**\r\n     * Get params for a request\r\n     * @function\r\n     */\r\n    getParams: function () {\r\n      return {\r\n        flowChunkNumber: this.offset + 1,\r\n        flowChunkSize: this.flowObj.opts.chunkSize,\r\n        flowCurrentChunkSize: this.endByte - this.startByte,\r\n        flowTotalSize: this.fileObj.size,\r\n        flowIdentifier: this.fileObj.uniqueIdentifier,\r\n        flowFilename: this.fileObj.name,\r\n        flowRelativePath: this.fileObj.relativePath,\r\n        flowTotalChunks: this.fileObj.chunks.length\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Get target option with query params\r\n     * @function\r\n     * @param params\r\n     * @returns {string}\r\n     */\r\n    getTarget: function(target, params){\r\n      if(target.indexOf('?') < 0) {\r\n        target += '?';\r\n      } else {\r\n        target += '&';\r\n      }\r\n      return target + params.join('&');\r\n    },\r\n\r\n    /**\r\n     * Makes a GET request without any data to see if the chunk has already\r\n     * been uploaded in a previous session\r\n     * @function\r\n     */\r\n    test: function () {\r\n      // Set up request and listen for event\r\n      this.xhr = new XMLHttpRequest();\r\n      this.xhr.addEventListener(\"load\", this.testHandler, false);\r\n      this.xhr.addEventListener(\"error\", this.testHandler, false);\r\n      var testMethod = evalOpts(this.flowObj.opts.testMethod, this.fileObj, this);\r\n      var data = this.prepareXhrRequest(testMethod, true);\r\n      this.xhr.send(data);\r\n    },\r\n\r\n    /**\r\n     * Finish preprocess state\r\n     * @function\r\n     */\r\n    preprocessFinished: function () {\r\n      // Re-compute the endByte after the preprocess function to allow an\r\n      // implementer of preprocess to set the fileObj size\r\n      this.endByte = this.computeEndByte();\r\n\r\n      this.preprocessState = 2;\r\n      this.send();\r\n    },\r\n\r\n    /**\r\n     * Finish read state\r\n     * @function\r\n     */\r\n    readFinished: function (bytes) {\r\n      this.readState = 2;\r\n      this.bytes = bytes;\r\n      this.send();\r\n    },\r\n\r\n\r\n    /**\r\n     * Uploads the actual data in a POST call\r\n     * @function\r\n     */\r\n    send: function () {\r\n      var preprocess = this.flowObj.opts.preprocess;\r\n      var read = this.flowObj.opts.readFileFn;\r\n      if (typeof preprocess === 'function') {\r\n        switch (this.preprocessState) {\r\n          case 0:\r\n            this.preprocessState = 1;\r\n            preprocess(this);\r\n            return;\r\n          case 1:\r\n            return;\r\n        }\r\n      }\r\n      switch (this.readState) {\r\n        case 0:\r\n          this.readState = 1;\r\n          read(this.fileObj, this.startByte, this.endByte, this.fileObj.file.type, this);\r\n          return;\r\n        case 1:\r\n          return;\r\n      }\r\n      if (this.flowObj.opts.testChunks && !this.tested) {\r\n        this.test();\r\n        return;\r\n      }\r\n\r\n      this.loaded = 0;\r\n      this.total = 0;\r\n      this.pendingRetry = false;\r\n\r\n      // Set up request and listen for event\r\n      this.xhr = new XMLHttpRequest();\r\n      this.xhr.upload.addEventListener('progress', this.progressHandler, false);\r\n      this.xhr.addEventListener(\"load\", this.doneHandler, false);\r\n      this.xhr.addEventListener(\"error\", this.doneHandler, false);\r\n\r\n      var uploadMethod = evalOpts(this.flowObj.opts.uploadMethod, this.fileObj, this);\r\n      var data = this.prepareXhrRequest(uploadMethod, false, this.flowObj.opts.method, this.bytes);\r\n      this.xhr.send(data);\r\n    },\r\n\r\n    /**\r\n     * Abort current xhr request\r\n     * @function\r\n     */\r\n    abort: function () {\r\n      // Abort and reset\r\n      var xhr = this.xhr;\r\n      this.xhr = null;\r\n      if (xhr) {\r\n        xhr.abort();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Retrieve current chunk upload status\r\n     * @function\r\n     * @returns {string} 'pending', 'uploading', 'success', 'error'\r\n     */\r\n    status: function (isTest) {\r\n      if (this.readState === 1) {\r\n        return 'reading';\r\n      } else if (this.pendingRetry || this.preprocessState === 1) {\r\n        // if pending retry then that's effectively the same as actively uploading,\r\n        // there might just be a slight delay before the retry starts\r\n        return 'uploading';\r\n      } else if (!this.xhr) {\r\n        return 'pending';\r\n      } else if (this.xhr.readyState < 4) {\r\n        // Status is really 'OPENED', 'HEADERS_RECEIVED'\r\n        // or 'LOADING' - meaning that stuff is happening\r\n        return 'uploading';\r\n      } else {\r\n        if (this.flowObj.opts.successStatuses.indexOf(this.xhr.status) > -1) {\r\n          // HTTP 200, perfect\r\n\t\t      // HTTP 202 Accepted - The request has been accepted for processing, but the processing has not been completed.\r\n          return 'success';\r\n        } else if (this.flowObj.opts.permanentErrors.indexOf(this.xhr.status) > -1 ||\r\n            !isTest && this.retries >= this.flowObj.opts.maxChunkRetries) {\r\n          // HTTP 413/415/500/501, permanent error\r\n          return 'error';\r\n        } else {\r\n          // this should never happen, but we'll reset and queue a retry\r\n          // a likely case for this would be 503 service unavailable\r\n          this.abort();\r\n          return 'pending';\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Get response from xhr request\r\n     * @function\r\n     * @returns {String}\r\n     */\r\n    message: function () {\r\n      return this.xhr ? this.xhr.responseText : '';\r\n    },\r\n\r\n    /**\r\n     * Get upload progress\r\n     * @function\r\n     * @returns {number}\r\n     */\r\n    progress: function () {\r\n      if (this.pendingRetry) {\r\n        return 0;\r\n      }\r\n      var s = this.status();\r\n      if (s === 'success' || s === 'error') {\r\n        return 1;\r\n      } else if (s === 'pending') {\r\n        return 0;\r\n      } else {\r\n        return this.total > 0 ? this.loaded / this.total : 0;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Count total size uploaded\r\n     * @function\r\n     * @returns {number}\r\n     */\r\n    sizeUploaded: function () {\r\n      var size = this.endByte - this.startByte;\r\n      // can't return only chunk.loaded value, because it is bigger than chunk size\r\n      if (this.status() !== 'success') {\r\n        size = this.progress() * size;\r\n      }\r\n      return size;\r\n    },\r\n\r\n    /**\r\n     * Prepare Xhr request. Set query, headers and data\r\n     * @param {string} method GET or POST\r\n     * @param {bool} isTest is this a test request\r\n     * @param {string} [paramsMethod] octet or form\r\n     * @param {Blob} [blob] to send\r\n     * @returns {FormData|Blob|Null} data to send\r\n     */\r\n    prepareXhrRequest: function(method, isTest, paramsMethod, blob) {\r\n      // Add data from the query options\r\n      var query = evalOpts(this.flowObj.opts.query, this.fileObj, this, isTest);\r\n      query = extend(query || {}, this.getParams());\r\n\r\n      var target = evalOpts(this.flowObj.opts.target, this.fileObj, this, isTest);\r\n      var data = null;\r\n      if (method === 'GET' || paramsMethod === 'octet') {\r\n        // Add data from the query options\r\n        var params = [];\r\n        each(query, function (v, k) {\r\n          params.push([encodeURIComponent(k), encodeURIComponent(v)].join('='));\r\n        });\r\n        target = this.getTarget(target, params);\r\n        data = blob || null;\r\n      } else {\r\n        // Add data from the query options\r\n        data = new FormData();\r\n        each(query, function (v, k) {\r\n          data.append(k, v);\r\n        });\r\n        if (typeof blob !== \"undefined\") data.append(this.flowObj.opts.fileParameterName, blob, this.fileObj.file.name);\r\n      }\r\n\r\n      this.xhr.open(method, target, true);\r\n      this.xhr.withCredentials = this.flowObj.opts.withCredentials;\r\n\r\n      // Add data from header options\r\n      each(evalOpts(this.flowObj.opts.headers, this.fileObj, this, isTest), function (v, k) {\r\n        this.xhr.setRequestHeader(k, v);\r\n      }, this);\r\n\r\n      return data;\r\n    }\r\n  };\r\n\r\n  return flowjs.FlowChunk = FlowChunk;\r\n\r\n});"]}