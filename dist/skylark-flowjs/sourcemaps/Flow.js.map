{"version":3,"sources":["Flow.js"],"names":["define","langx","flowjs","utils","FlowFile","each","async","extend","arrayRemove","ie10plus","window","navigator","msPointerEnabled","Flow","opts","this","support","File","Blob","FileList","prototype","slice","webkitSlice","mozSlice","supportDirectory","test","userAgent","files","defaults","chunkSize","forceChunkSize","simultaneousUploads","singleFile","fileParameterName","progressCallbacksInterval","speedSmoothingFactor","query","headers","withCredentials","preprocess","method","testMethod","uploadMethod","prioritizeFirstAndLastChunk","allowDuplicateUploads","target","testChunks","generateUniqueIdentifier","maxChunkRetries","chunkRetryInterval","permanentErrors","successStatuses","onDropStopPropagation","initFileFn","readFileFn","webAPIFileRead","events","$","onDrop","event","stopPropagation","preventDefault","dataTransfer","items","webkitGetAsEntry","webkitReadDataTransfer","addFiles","preventEvent","fileObj","startByte","endByte","fileType","chunk","function_name","file","readFinished","on","callback","toLowerCase","hasOwnProperty","push","off","fn","undefined","fire","args","Array","call","arguments","apply","unshift","queue","length","fileReadSuccess","fullPath","relativePath","substring","decrement","readError","fileError","item","entry","isFile","getAsFile","readDirectory","reader","readEntries","entries","isDirectory","createReader","custom","webkitRelativePath","fileName","name","size","replace","uploadNextChunk","preventEvents","found","paused","chunks","status","send","outstanding","isComplete","assignBrowse","domNodes","attributes","Element","domNode","input","tagName","type","document","createElement","setAttribute","style","visibility","position","width","height","appendChild","addEventListener","click","value","key","e","assignDrop","unAssignDrop","removeEventListener","isUploading","uploading","_shouldUploadNext","num","should","upload","ret","started","resume","pause","cancel","i","progress","totalDone","totalSize","addFile","fileList","uniqueIdentifier","getFromUniqueIdentifier","f","removeFile","splice","abort","getSize","sizeUploaded","timeRemaining","sizeDelta","averageSpeed","error","Number","POSITIVE_INFINITY","Math","floor"],"mappings":"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","file":"../Flow.js","sourcesContent":["define([\n  \"skylark-langx/langx\",\n  \"./flowjs\",\n  \"./utils\",\n  \"./FlowFile\"\n],function(langx,flowjs,utils,FlowFile){\n\n  'use strict';\n\n  var each = utils.each,\n      async = utils.async,\n      extend = utils.extend,\n      arrayRemove = utils.arrayRemove;\n\n  // ie10+\n  var ie10plus = window.navigator.msPointerEnabled;\n  /**\n   * Flow.js is a library providing multiple simultaneous, stable and\n   * resumable uploads via the HTML5 File API.\n   * @param [opts]\n   * @param {number} [opts.chunkSize]\n   * @param {bool} [opts.forceChunkSize]\n   * @param {number} [opts.simultaneousUploads]\n   * @param {bool} [opts.singleFile]\n   * @param {string} [opts.fileParameterName]\n   * @param {number} [opts.progressCallbacksInterval]\n   * @param {number} [opts.speedSmoothingFactor]\n   * @param {Object|Function} [opts.query]\n   * @param {Object|Function} [opts.headers]\n   * @param {bool} [opts.withCredentials]\n   * @param {Function} [opts.preprocess]\n   * @param {string} [opts.method]\n   * @param {string|Function} [opts.testMethod]\n   * @param {string|Function} [opts.uploadMethod]\n   * @param {bool} [opts.prioritizeFirstAndLastChunk]\n   * @param {bool} [opts.allowDuplicateUploads]\n   * @param {string|Function} [opts.target]\n   * @param {number} [opts.maxChunkRetries]\n   * @param {number} [opts.chunkRetryInterval]\n   * @param {Array.<number>} [opts.permanentErrors]\n   * @param {Array.<number>} [opts.successStatuses]\n   * @param {Function} [opts.initFileFn]\n   * @param {Function} [opts.readFileFn]\n   * @param {Function} [opts.generateUniqueIdentifier]\n   * @constructor\n   */\n  function Flow(opts) {\n    /**\n     * Supported by browser?\n     * @type {boolean}\n     */\n    this.support = (\n        typeof File !== 'undefined' &&\n        typeof Blob !== 'undefined' &&\n        typeof FileList !== 'undefined' &&\n        (\n          !!Blob.prototype.slice || !!Blob.prototype.webkitSlice || !!Blob.prototype.mozSlice ||\n          false\n        ) // slicing files support\n    );\n\n    if (!this.support) {\n      return ;\n    }\n\n    /**\n     * Check if directory upload is supported\n     * @type {boolean}\n     */\n    this.supportDirectory = (\n        /Chrome/.test(window.navigator.userAgent) ||\n        /Firefox/.test(window.navigator.userAgent) ||\n        /Edge/.test(window.navigator.userAgent)\n    );\n\n    /**\n     * List of FlowFile objects\n     * @type {Array.<FlowFile>}\n     */\n    this.files = [];\n\n    /**\n     * Default options for flow.js\n     * @type {Object}\n     */\n    this.defaults = {\n      chunkSize: 1024 * 1024,\n      forceChunkSize: false,\n      simultaneousUploads: 3,\n      singleFile: false,\n      fileParameterName: 'file',\n      progressCallbacksInterval: 500,\n      speedSmoothingFactor: 0.1,\n      query: {},\n      headers: {},\n      withCredentials: false,\n      preprocess: null,\n      method: 'multipart',\n      testMethod: 'GET',\n      uploadMethod: 'POST',\n      prioritizeFirstAndLastChunk: false,\n      allowDuplicateUploads: false,\n      target: '/',\n      testChunks: true,\n      generateUniqueIdentifier: null,\n      maxChunkRetries: 0,\n      chunkRetryInterval: null,\n      permanentErrors: [404, 413, 415, 500, 501],\n      successStatuses: [200, 201, 202],\n      onDropStopPropagation: false,\n      initFileFn: null,\n      readFileFn: webAPIFileRead\n    };\n\n    /**\n     * Current options\n     * @type {Object}\n     */\n    this.opts = {};\n\n    /**\n     * List of events:\n     *  key stands for event name\n     *  value array list of callbacks\n     * @type {}\n     */\n    this.events = {};\n\n    var $ = this;\n\n    /**\n     * On drop event\n     * @function\n     * @param {MouseEvent} event\n     */\n    this.onDrop = function (event) {\n      if ($.opts.onDropStopPropagation) {\n        event.stopPropagation();\n      }\n      event.preventDefault();\n      var dataTransfer = event.dataTransfer;\n      if (dataTransfer.items && dataTransfer.items[0] &&\n        dataTransfer.items[0].webkitGetAsEntry) {\n        $.webkitReadDataTransfer(event);\n      } else {\n        $.addFiles(dataTransfer.files, event);\n      }\n    };\n\n    /**\n     * Prevent default\n     * @function\n     * @param {MouseEvent} event\n     */\n    this.preventEvent = function (event) {\n      event.preventDefault();\n    };\n\n\n    /**\n     * Current options\n     * @type {Object}\n     */\n    this.opts = extend({}, this.defaults, opts || {});\n\n  }\n\n  Flow.prototype = {\n    /**\n     * Set a callback for an event, possible events:\n     * fileSuccess(file), fileProgress(file), fileAdded(file, event),\n     * fileRemoved(file), fileRetry(file), fileError(file, message),\n     * complete(), progress(), error(message, file), pause()\n     * @function\n     * @param {string} event\n     * @param {Function} callback\n     */\n    on: function (event, callback) {\n      event = event.toLowerCase();\n      if (!this.events.hasOwnProperty(event)) {\n        this.events[event] = [];\n      }\n      this.events[event].push(callback);\n    },\n\n    /**\n     * Remove event callback\n     * @function\n     * @param {string} [event] removes all events if not specified\n     * @param {Function} [fn] removes all callbacks of event if not specified\n     */\n    off: function (event, fn) {\n      if (event !== undefined) {\n        event = event.toLowerCase();\n        if (fn !== undefined) {\n          if (this.events.hasOwnProperty(event)) {\n            arrayRemove(this.events[event], fn);\n          }\n        } else {\n          delete this.events[event];\n        }\n      } else {\n        this.events = {};\n      }\n    },\n\n    /**\n     * Fire an event\n     * @function\n     * @param {string} event event name\n     * @param {...} args arguments of a callback\n     * @return {bool} value is false if at least one of the event handlers which handled this event\n     * returned false. Otherwise it returns true.\n     */\n    fire: function (event, args) {\n      // `arguments` is an object, not array, in FF, so:\n      args = Array.prototype.slice.call(arguments);\n      event = event.toLowerCase();\n      var preventDefault = false;\n      if (this.events.hasOwnProperty(event)) {\n        each(this.events[event], function (callback) {\n          preventDefault = callback.apply(this, args.slice(1)) === false || preventDefault;\n        }, this);\n      }\n      if (event != 'catchall') {\n        args.unshift('catchAll');\n        preventDefault = this.fire.apply(this, args) === false || preventDefault;\n      }\n      return !preventDefault;\n    },\n\n    /**\n     * Read webkit dataTransfer object\n     * @param event\n     */\n    webkitReadDataTransfer: function (event) {\n      var $ = this;\n      var queue = event.dataTransfer.items.length;\n      var files = [];\n      each(event.dataTransfer.items, function (item) {\n        var entry = item.webkitGetAsEntry();\n        if (!entry) {\n          decrement();\n          return ;\n        }\n        if (entry.isFile) {\n          // due to a bug in Chrome's File System API impl - #149735\n          fileReadSuccess(item.getAsFile(), entry.fullPath);\n        } else {\n          readDirectory(entry.createReader());\n        }\n      });\n      function readDirectory(reader) {\n        reader.readEntries(function (entries) {\n          if (entries.length) {\n            queue += entries.length;\n            each(entries, function(entry) {\n              if (entry.isFile) {\n                var fullPath = entry.fullPath;\n                entry.file(function (file) {\n                  fileReadSuccess(file, fullPath);\n                }, readError);\n              } else if (entry.isDirectory) {\n                readDirectory(entry.createReader());\n              }\n            });\n            readDirectory(reader);\n          } else {\n            decrement();\n          }\n        }, readError);\n      }\n      function fileReadSuccess(file, fullPath) {\n        // relative path should not start with \"/\"\n        file.relativePath = fullPath.substring(1);\n        files.push(file);\n        decrement();\n      }\n      function readError(fileError) {\n        throw fileError;\n      }\n      function decrement() {\n        if (--queue == 0) {\n          $.addFiles(files, event);\n        }\n      }\n    },\n\n    /**\n     * Generate unique identifier for a file\n     * @function\n     * @param {FlowFile} file\n     * @returns {string}\n     */\n    generateUniqueIdentifier: function (file) {\n      var custom = this.opts.generateUniqueIdentifier;\n      if (typeof custom === 'function') {\n        return custom(file);\n      }\n      // Some confusion in different versions of Firefox\n      var relativePath = file.relativePath || file.webkitRelativePath || file.fileName || file.name;\n      return file.size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, '');\n    },\n\n    /**\n     * Upload next chunk from the queue\n     * @function\n     * @returns {boolean}\n     * @private\n     */\n    uploadNextChunk: function (preventEvents) {\n      // In some cases (such as videos) it's really handy to upload the first\n      // and last chunk of a file quickly; this let's the server check the file's\n      // metadata and determine if there's even a point in continuing.\n      var found = false;\n      if (this.opts.prioritizeFirstAndLastChunk) {\n        each(this.files, function (file) {\n          if (!file.paused && file.chunks.length &&\n            file.chunks[0].status() === 'pending') {\n            file.chunks[0].send();\n            found = true;\n            return false;\n          }\n          if (!file.paused && file.chunks.length > 1 &&\n            file.chunks[file.chunks.length - 1].status() === 'pending') {\n            file.chunks[file.chunks.length - 1].send();\n            found = true;\n            return false;\n          }\n        });\n        if (found) {\n          return found;\n        }\n      }\n\n      // Now, simply look for the next, best thing to upload\n      each(this.files, function (file) {\n        if (!file.paused) {\n          each(file.chunks, function (chunk) {\n            if (chunk.status() === 'pending') {\n              chunk.send();\n              found = true;\n              return false;\n            }\n          });\n        }\n        if (found) {\n          return false;\n        }\n      });\n      if (found) {\n        return true;\n      }\n\n      // The are no more outstanding chunks to upload, check is everything is done\n      var outstanding = false;\n      each(this.files, function (file) {\n        if (!file.isComplete()) {\n          outstanding = true;\n          return false;\n        }\n      });\n      if (!outstanding && !preventEvents) {\n        // All chunks have been uploaded, complete\n        async(function () {\n          this.fire('complete');\n        }, this);\n      }\n      return false;\n    },\n\n\n    /**\n     * Assign a browse action to one or more DOM nodes.\n     * @function\n     * @param {Element|Array.<Element>} domNodes\n     * @param {boolean} isDirectory Pass in true to allow directories to\n     * @param {boolean} singleFile prevent multi file upload\n     * @param {Object} attributes set custom attributes:\n     *  http://www.w3.org/TR/html-markup/input.file.html#input.file-attributes\n     *  eg: accept: 'image/*'\n     * be selected (Chrome only).\n     */\n    assignBrowse: function (domNodes, isDirectory, singleFile, attributes) {\n      if (domNodes instanceof Element) {\n        domNodes = [domNodes];\n      }\n\n      each(domNodes, function (domNode) {\n        var input;\n        if (domNode.tagName === 'INPUT' && domNode.type === 'file') {\n          input = domNode;\n        } else {\n          input = document.createElement('input');\n          input.setAttribute('type', 'file');\n          // display:none - not working in opera 12\n          extend(input.style, {\n            visibility: 'hidden',\n            position: 'absolute',\n            width: '1px',\n            height: '1px'\n          });\n          // for opera 12 browser, input must be assigned to a document\n          domNode.appendChild(input);\n          // https://developer.mozilla.org/en/using_files_from_web_applications)\n          // event listener is executed two times\n          // first one - original mouse click event\n          // second - input.click(), input is inside domNode\n          domNode.addEventListener('click', function() {\n            input.click();\n          }, false);\n        }\n        if (!this.opts.singleFile && !singleFile) {\n          input.setAttribute('multiple', 'multiple');\n        }\n        if (isDirectory) {\n          input.setAttribute('webkitdirectory', 'webkitdirectory');\n        }\n        each(attributes, function (value, key) {\n          input.setAttribute(key, value);\n        });\n        // When new files are added, simply append them to the overall list\n        var $ = this;\n        input.addEventListener('change', function (e) {\n       \t  if (e.target.value) {\n            $.addFiles(e.target.files, e);\n            e.target.value = '';\n       \t  }\n        }, false);\n      }, this);\n    },\n\n    /**\n     * Assign one or more DOM nodes as a drop target.\n     * @function\n     * @param {Element|Array.<Element>} domNodes\n     */\n    assignDrop: function (domNodes) {\n      if (typeof domNodes.length === 'undefined') {\n        domNodes = [domNodes];\n      }\n      each(domNodes, function (domNode) {\n        domNode.addEventListener('dragover', this.preventEvent, false);\n        domNode.addEventListener('dragenter', this.preventEvent, false);\n        domNode.addEventListener('drop', this.onDrop, false);\n      }, this);\n    },\n\n    /**\n     * Un-assign drop event from DOM nodes\n     * @function\n     * @param domNodes\n     */\n    unAssignDrop: function (domNodes) {\n      if (typeof domNodes.length === 'undefined') {\n        domNodes = [domNodes];\n      }\n      each(domNodes, function (domNode) {\n        domNode.removeEventListener('dragover', this.preventEvent);\n        domNode.removeEventListener('dragenter', this.preventEvent);\n        domNode.removeEventListener('drop', this.onDrop);\n      }, this);\n    },\n\n    /**\n     * Returns a boolean indicating whether or not the instance is currently\n     * uploading anything.\n     * @function\n     * @returns {boolean}\n     */\n    isUploading: function () {\n      var uploading = false;\n      each(this.files, function (file) {\n        if (file.isUploading()) {\n          uploading = true;\n          return false;\n        }\n      });\n      return uploading;\n    },\n\n    /**\n     * should upload next chunk\n     * @function\n     * @returns {boolean|number}\n     */\n    _shouldUploadNext: function () {\n      var num = 0;\n      var should = true;\n      var simultaneousUploads = this.opts.simultaneousUploads;\n      each(this.files, function (file) {\n        each(file.chunks, function(chunk) {\n          if (chunk.status() === 'uploading') {\n            num++;\n            if (num >= simultaneousUploads) {\n              should = false;\n              return false;\n            }\n          }\n        });\n      });\n      // if should is true then return uploading chunks's length\n      return should && num;\n    },\n\n    /**\n     * Start or resume uploading.\n     * @function\n     */\n    upload: function () {\n      // Make sure we don't start too many uploads at once\n      var ret = this._shouldUploadNext();\n      if (ret === false) {\n        return;\n      }\n      // Kick off the queue\n      this.fire('uploadStart');\n      var started = false;\n      for (var num = 1; num <= this.opts.simultaneousUploads - ret; num++) {\n        started = this.uploadNextChunk(true) || started;\n      }\n      if (!started) {\n        async(function () {\n          this.fire('complete');\n        }, this);\n      }\n    },\n\n    /**\n     * Resume uploading.\n     * @function\n     */\n    resume: function () {\n      each(this.files, function (file) {\n        if (!file.isComplete()) {\n          file.resume();\n        }\n      });\n    },\n\n    /**\n     * Pause uploading.\n     * @function\n     */\n    pause: function () {\n      each(this.files, function (file) {\n        file.pause();\n      });\n    },\n\n    /**\n     * Cancel upload of all FlowFile objects and remove them from the list.\n     * @function\n     */\n    cancel: function () {\n      for (var i = this.files.length - 1; i >= 0; i--) {\n        this.files[i].cancel();\n      }\n    },\n\n    /**\n     * Returns a number between 0 and 1 indicating the current upload progress\n     * of all files.\n     * @function\n     * @returns {number}\n     */\n    progress: function () {\n      var totalDone = 0;\n      var totalSize = 0;\n      // Resume all chunks currently being uploaded\n      each(this.files, function (file) {\n        totalDone += file.progress() * file.size;\n        totalSize += file.size;\n      });\n      return totalSize > 0 ? totalDone / totalSize : 0;\n    },\n\n    /**\n     * Add a HTML5 File object to the list of files.\n     * @function\n     * @param {File} file\n     * @param {Event} [event] event is optional\n     */\n    addFile: function (file, event) {\n      this.addFiles([file], event);\n    },\n\n    /**\n     * Add a HTML5 File object to the list of files.\n     * @function\n     * @param {FileList|Array} fileList\n     * @param {Event} [event] event is optional\n     */\n    addFiles: function (fileList, event) {\n      var files = [];\n      each(fileList, function (file) {\n        // https://github.com/flowjs/flow.js/issues/55\n        if ((!ie10plus || ie10plus && file.size > 0) && !(file.size % 4096 === 0 && (file.name === '.' || file.fileName === '.'))) {\n          var uniqueIdentifier = this.generateUniqueIdentifier(file);\n          if (this.opts.allowDuplicateUploads || !this.getFromUniqueIdentifier(uniqueIdentifier)) {\n            var f = new FlowFile(this, file, uniqueIdentifier);\n            if (this.fire('fileAdded', f, event)) {\n              files.push(f);\n            }\n          }\n        }\n      }, this);\n      if (this.fire('filesAdded', files, event)) {\n        each(files, function (file) {\n          if (this.opts.singleFile && this.files.length > 0) {\n            this.removeFile(this.files[0]);\n          }\n          this.files.push(file);\n        }, this);\n        this.fire('filesSubmitted', files, event);\n      }\n    },\n\n\n    /**\n     * Cancel upload of a specific FlowFile object from the list.\n     * @function\n     * @param {FlowFile} file\n     */\n    removeFile: function (file) {\n      for (var i = this.files.length - 1; i >= 0; i--) {\n        if (this.files[i] === file) {\n          this.files.splice(i, 1);\n          file.abort();\n          this.fire('fileRemoved', file);\n        }\n      }\n    },\n\n    /**\n     * Look up a FlowFile object by its unique identifier.\n     * @function\n     * @param {string} uniqueIdentifier\n     * @returns {boolean|FlowFile} false if file was not found\n     */\n    getFromUniqueIdentifier: function (uniqueIdentifier) {\n      var ret = false;\n      each(this.files, function (file) {\n        if (file.uniqueIdentifier === uniqueIdentifier) {\n          ret = file;\n        }\n      });\n      return ret;\n    },\n\n    /**\n     * Returns the total size of all files in bytes.\n     * @function\n     * @returns {number}\n     */\n    getSize: function () {\n      var totalSize = 0;\n      each(this.files, function (file) {\n        totalSize += file.size;\n      });\n      return totalSize;\n    },\n\n    /**\n     * Returns the total size uploaded of all files in bytes.\n     * @function\n     * @returns {number}\n     */\n    sizeUploaded: function () {\n      var size = 0;\n      each(this.files, function (file) {\n        size += file.sizeUploaded();\n      });\n      return size;\n    },\n\n    /**\n     * Returns remaining time to upload all files in seconds. Accuracy is based on average speed.\n     * If speed is zero, time remaining will be equal to positive infinity `Number.POSITIVE_INFINITY`\n     * @function\n     * @returns {number}\n     */\n    timeRemaining: function () {\n      var sizeDelta = 0;\n      var averageSpeed = 0;\n      each(this.files, function (file) {\n        if (!file.paused && !file.error) {\n          sizeDelta += file.size - file.sizeUploaded();\n          averageSpeed += file.averageSpeed;\n        }\n      });\n      if (sizeDelta && !averageSpeed) {\n        return Number.POSITIVE_INFINITY;\n      }\n      if (!sizeDelta && !averageSpeed) {\n        return 0;\n      }\n      return Math.floor(sizeDelta / averageSpeed);\n    }\n  };\n\n\n\n  /**\n   * Default read function using the webAPI\n   *\n   * @function webAPIFileRead(fileObj, startByte, endByte, fileType, chunk)\n   *\n   */\n  function webAPIFileRead(fileObj, startByte, endByte, fileType, chunk) {\n    var function_name = 'slice';\n\n    if (fileObj.file.slice)\n      function_name =  'slice';\n    else if (fileObj.file.mozSlice)\n      function_name = 'mozSlice';\n    else if (fileObj.file.webkitSlice)\n      function_name = 'webkitSlice';\n\n    chunk.readFinished(fileObj.file[function_name](startByte, endByte, fileType));\n  }\n\n\n  return flowjs.Flow = Flow;\n\n});"]}