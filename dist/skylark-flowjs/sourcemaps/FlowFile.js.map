{"version":3,"sources":["FlowFile.js"],"names":["define","langx","flowjs","utils","FlowChunk","each","FlowFile","flowObj","file","uniqueIdentifier","this","bytes","name","fileName","size","relativePath","webkitRelativePath","undefined","generateUniqueIdentifier","chunks","paused","error","averageSpeed","currentSpeed","_lastProgressCallback","Date","now","_prevUploadedSize","_prevProgress","bootstrap","prototype","measureSpeed","timeSpan","smoothingFactor","opts","speedSmoothingFactor","uploaded","sizeUploaded","Math","max","chunkEvent","chunk","event","message","progressCallbacksInterval","fire","abort","isComplete","pause","resume","upload","reset","c","status","uploadNextChunk","cancel","removeFile","retry","initFileFn","round","forceChunkSize","ceil","floor","chunkSize","offset","push","progress","length","bytesLoaded","endByte","startByte","percent","isUploading","uploading","outstanding","preprocessState","readState","timeRemaining","delta","Number","POSITIVE_INFINITY","getType","type","split","getExtension","substr","lastIndexOf","toLowerCase"],"mappings":"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","file":"../FlowFile.js","sourcesContent":["define([\r\n  \"skylark-langx/langx\",\r\n  \"./flowjs\",\r\n  \"./utils\",\r\n  \"./FlowChunk\"\r\n],function(langx,flowjs,utils,FlowChunk){\r\n  'use strict';\r\n\r\n  var each = utils.each;\r\n\r\n  /**\r\n   * FlowFile class\r\n   * @name FlowFile\r\n   * @param {Flow} flowObj\r\n   * @param {File} file\r\n   * @param {string} uniqueIdentifier\r\n   * @constructor\r\n   */\r\n  function FlowFile(flowObj, file, uniqueIdentifier) {\r\n\r\n    /**\r\n     * Reference to parent Flow instance\r\n     * @type {Flow}\r\n     */\r\n    this.flowObj = flowObj;\r\n\r\n    /**\r\n     * Used to store the bytes read\r\n     * @type {Blob|string}\r\n     */\r\n    this.bytes = null;\r\n\r\n    /**\r\n     * Reference to file\r\n     * @type {File}\r\n     */\r\n    this.file = file;\r\n\r\n    /**\r\n     * File name. Some confusion in different versions of Firefox\r\n     * @type {string}\r\n     */\r\n    this.name = file.fileName || file.name;\r\n\r\n    /**\r\n     * File size\r\n     * @type {number}\r\n     */\r\n    this.size = file.size;\r\n\r\n    /**\r\n     * Relative file path\r\n     * @type {string}\r\n     */\r\n    this.relativePath = file.relativePath || file.webkitRelativePath || this.name;\r\n\r\n    /**\r\n     * File unique identifier\r\n     * @type {string}\r\n     */\r\n    this.uniqueIdentifier = (uniqueIdentifier === undefined ? flowObj.generateUniqueIdentifier(file) : uniqueIdentifier);\r\n\r\n    /**\r\n     * List of chunks\r\n     * @type {Array.<FlowChunk>}\r\n     */\r\n    this.chunks = [];\r\n\r\n    /**\r\n     * Indicated if file is paused\r\n     * @type {boolean}\r\n     */\r\n    this.paused = false;\r\n\r\n    /**\r\n     * Indicated if file has encountered an error\r\n     * @type {boolean}\r\n     */\r\n    this.error = false;\r\n\r\n    /**\r\n     * Average upload speed\r\n     * @type {number}\r\n     */\r\n    this.averageSpeed = 0;\r\n\r\n    /**\r\n     * Current upload speed\r\n     * @type {number}\r\n     */\r\n    this.currentSpeed = 0;\r\n\r\n    /**\r\n     * Date then progress was called last time\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this._lastProgressCallback = Date.now();\r\n\r\n    /**\r\n     * Previously uploaded file size\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this._prevUploadedSize = 0;\r\n\r\n    /**\r\n     * Holds previous progress\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this._prevProgress = 0;\r\n\r\n    this.bootstrap();\r\n  }\r\n\r\n  FlowFile.prototype = {\r\n    /**\r\n     * Update speed parameters\r\n     * @link http://stackoverflow.com/questions/2779600/how-to-estimate-download-time-remaining-accurately\r\n     * @function\r\n     */\r\n    measureSpeed: function () {\r\n      var timeSpan = Date.now() - this._lastProgressCallback;\r\n      if (!timeSpan) {\r\n        return ;\r\n      }\r\n      var smoothingFactor = this.flowObj.opts.speedSmoothingFactor;\r\n      var uploaded = this.sizeUploaded();\r\n      // Prevent negative upload speed after file upload resume\r\n      this.currentSpeed = Math.max((uploaded - this._prevUploadedSize) / timeSpan * 1000, 0);\r\n      this.averageSpeed = smoothingFactor * this.currentSpeed + (1 - smoothingFactor) * this.averageSpeed;\r\n      this._prevUploadedSize = uploaded;\r\n    },\r\n\r\n    /**\r\n     * For internal usage only.\r\n     * Callback when something happens within the chunk.\r\n     * @function\r\n     * @param {FlowChunk} chunk\r\n     * @param {string} event can be 'progress', 'success', 'error' or 'retry'\r\n     * @param {string} [message]\r\n     */\r\n    chunkEvent: function (chunk, event, message) {\r\n      switch (event) {\r\n        case 'progress':\r\n          if (Date.now() - this._lastProgressCallback <\r\n            this.flowObj.opts.progressCallbacksInterval) {\r\n            break;\r\n          }\r\n          this.measureSpeed();\r\n          this.flowObj.fire('fileProgress', this, chunk);\r\n          this.flowObj.fire('progress');\r\n          this._lastProgressCallback = Date.now();\r\n          break;\r\n        case 'error':\r\n          this.error = true;\r\n          this.abort(true);\r\n          this.flowObj.fire('fileError', this, message, chunk);\r\n          this.flowObj.fire('error', message, this, chunk);\r\n          break;\r\n        case 'success':\r\n          if (this.error) {\r\n            return;\r\n          }\r\n          this.measureSpeed();\r\n          this.flowObj.fire('fileProgress', this, chunk);\r\n          this.flowObj.fire('progress');\r\n          this._lastProgressCallback = Date.now();\r\n          if (this.isComplete()) {\r\n            this.currentSpeed = 0;\r\n            this.averageSpeed = 0;\r\n            this.flowObj.fire('fileSuccess', this, message, chunk);\r\n          }\r\n          break;\r\n        case 'retry':\r\n          this.flowObj.fire('fileRetry', this, chunk);\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Pause file upload\r\n     * @function\r\n     */\r\n    pause: function() {\r\n      this.paused = true;\r\n      this.abort();\r\n    },\r\n\r\n    /**\r\n     * Resume file upload\r\n     * @function\r\n     */\r\n    resume: function() {\r\n      this.paused = false;\r\n      this.flowObj.upload();\r\n    },\r\n\r\n    /**\r\n     * Abort current upload\r\n     * @function\r\n     */\r\n    abort: function (reset) {\r\n      this.currentSpeed = 0;\r\n      this.averageSpeed = 0;\r\n      var chunks = this.chunks;\r\n      if (reset) {\r\n        this.chunks = [];\r\n      }\r\n      each(chunks, function (c) {\r\n        if (c.status() === 'uploading') {\r\n          c.abort();\r\n          this.flowObj.uploadNextChunk();\r\n        }\r\n      }, this);\r\n    },\r\n\r\n    /**\r\n     * Cancel current upload and remove from a list\r\n     * @function\r\n     */\r\n    cancel: function () {\r\n      this.flowObj.removeFile(this);\r\n    },\r\n\r\n    /**\r\n     * Retry aborted file upload\r\n     * @function\r\n     */\r\n    retry: function () {\r\n      this.bootstrap();\r\n      this.flowObj.upload();\r\n    },\r\n\r\n    /**\r\n     * Clear current chunks and slice file again\r\n     * @function\r\n     */\r\n    bootstrap: function () {\r\n      if (typeof this.flowObj.opts.initFileFn === \"function\") {\r\n        this.flowObj.opts.initFileFn(this);\r\n      }\r\n\r\n      this.abort(true);\r\n      this.error = false;\r\n      // Rebuild stack of chunks from file\r\n      this._prevProgress = 0;\r\n      var round = this.flowObj.opts.forceChunkSize ? Math.ceil : Math.floor;\r\n      var chunks = Math.max(\r\n        round(this.size / this.flowObj.opts.chunkSize), 1\r\n      );\r\n      for (var offset = 0; offset < chunks; offset++) {\r\n        this.chunks.push(\r\n          new FlowChunk(this.flowObj, this, offset)\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Get current upload progress status\r\n     * @function\r\n     * @returns {number} from 0 to 1\r\n     */\r\n    progress: function () {\r\n      if (this.error) {\r\n        return 1;\r\n      }\r\n      if (this.chunks.length === 1) {\r\n        this._prevProgress = Math.max(this._prevProgress, this.chunks[0].progress());\r\n        return this._prevProgress;\r\n      }\r\n      // Sum up progress across everything\r\n      var bytesLoaded = 0;\r\n      each(this.chunks, function (c) {\r\n        // get chunk progress relative to entire file\r\n        bytesLoaded += c.progress() * (c.endByte - c.startByte);\r\n      });\r\n      var percent = bytesLoaded / this.size;\r\n      // We don't want to lose percentages when an upload is paused\r\n      this._prevProgress = Math.max(this._prevProgress, percent > 0.9999 ? 1 : percent);\r\n      return this._prevProgress;\r\n    },\r\n\r\n    /**\r\n     * Indicates if file is being uploaded at the moment\r\n     * @function\r\n     * @returns {boolean}\r\n     */\r\n    isUploading: function () {\r\n      var uploading = false;\r\n      each(this.chunks, function (chunk) {\r\n        if (chunk.status() === 'uploading') {\r\n          uploading = true;\r\n          return false;\r\n        }\r\n      });\r\n      return uploading;\r\n    },\r\n\r\n    /**\r\n     * Indicates if file is has finished uploading and received a response\r\n     * @function\r\n     * @returns {boolean}\r\n     */\r\n    isComplete: function () {\r\n      var outstanding = false;\r\n      each(this.chunks, function (chunk) {\r\n        var status = chunk.status();\r\n        if (status === 'pending' || status === 'uploading' || status === 'reading' || chunk.preprocessState === 1 || chunk.readState === 1) {\r\n          outstanding = true;\r\n          return false;\r\n        }\r\n      });\r\n      return !outstanding;\r\n    },\r\n\r\n    /**\r\n     * Count total size uploaded\r\n     * @function\r\n     * @returns {number}\r\n     */\r\n    sizeUploaded: function () {\r\n      var size = 0;\r\n      each(this.chunks, function (chunk) {\r\n        size += chunk.sizeUploaded();\r\n      });\r\n      return size;\r\n    },\r\n\r\n    /**\r\n     * Returns remaining time to finish upload file in seconds. Accuracy is based on average speed.\r\n     * If speed is zero, time remaining will be equal to positive infinity `Number.POSITIVE_INFINITY`\r\n     * @function\r\n     * @returns {number}\r\n     */\r\n    timeRemaining: function () {\r\n      if (this.paused || this.error) {\r\n        return 0;\r\n      }\r\n      var delta = this.size - this.sizeUploaded();\r\n      if (delta && !this.averageSpeed) {\r\n        return Number.POSITIVE_INFINITY;\r\n      }\r\n      if (!delta && !this.averageSpeed) {\r\n        return 0;\r\n      }\r\n      return Math.floor(delta / this.averageSpeed);\r\n    },\r\n\r\n    /**\r\n     * Get file type\r\n     * @function\r\n     * @returns {string}\r\n     */\r\n    getType: function () {\r\n      return this.file.type && this.file.type.split('/')[1];\r\n    },\r\n\r\n    /**\r\n     * Get file extension\r\n     * @function\r\n     * @returns {string}\r\n     */\r\n    getExtension: function () {\r\n      return this.name.substr((~-this.name.lastIndexOf(\".\") >>> 0) + 2).toLowerCase();\r\n    }\r\n  };\r\n\t\r\n\r\n  return flowjs.FlowFile = FlowFile;\r\n});"]}