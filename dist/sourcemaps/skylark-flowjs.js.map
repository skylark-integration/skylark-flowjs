{"version":3,"sources":["skylark-flowjs.js"],"names":["define","skylark","itg","flowjs","langx","each","obj","callback","context","key","length","call","hasOwnProperty","arrayRemove","array","value","index","indexOf","splice","evalOpts","data","args","Array","prototype","slice","arguments","apply","async","fn","setTimeout","bind","extend","dst","src","utils","FlowChunk","flowObj","fileObj","offset","this","tested","retries","pendingRetry","preprocessState","readState","loaded","total","chunkSize","opts","startByte","computeEndByte","endByte","Math","min","size","forceChunkSize","xhr","$","event","unshift","chunkEvent","progressHandler","lengthComputable","testHandler","status","message","uploadNextChunk","paused","send","doneHandler","abort","retryInterval","chunkRetryInterval","getParams","flowChunkNumber","flowChunkSize","flowCurrentChunkSize","flowTotalSize","flowIdentifier","uniqueIdentifier","flowFilename","name","flowRelativePath","relativePath","flowTotalChunks","chunks","getTarget","target","params","join","test","XMLHttpRequest","addEventListener","testMethod","prepareXhrRequest","preprocessFinished","readFinished","bytes","preprocess","read","readFileFn","file","type","testChunks","upload","uploadMethod","method","isTest","readyState","successStatuses","permanentErrors","maxChunkRetries","responseText","progress","s","sizeUploaded","paramsMethod","blob","query","v","k","push","encodeURIComponent","FormData","append","fileParameterName","open","withCredentials","headers","setRequestHeader","FlowFile","fileName","webkitRelativePath","undefined","generateUniqueIdentifier","error","averageSpeed","currentSpeed","_lastProgressCallback","Date","now","_prevUploadedSize","_prevProgress","bootstrap","measureSpeed","timeSpan","smoothingFactor","speedSmoothingFactor","uploaded","max","chunk","progressCallbacksInterval","fire","isComplete","pause","resume","reset","c","cancel","removeFile","retry","initFileFn","round","ceil","floor","bytesLoaded","percent","isUploading","uploading","outstanding","timeRemaining","delta","Number","POSITIVE_INFINITY","getType","split","getExtension","substr","lastIndexOf","toLowerCase","ie10plus","window","navigator","msPointerEnabled","Flow","support","File","Blob","FileList","webkitSlice","mozSlice","supportDirectory","userAgent","files","defaults","simultaneousUploads","singleFile","prioritizeFirstAndLastChunk","allowDuplicateUploads","onDropStopPropagation","webAPIFileRead","events","onDrop","stopPropagation","preventDefault","dataTransfer","items","webkitGetAsEntry","webkitReadDataTransfer","addFiles","preventEvent","fileType","function_name","on","off","queue","fileReadSuccess","fullPath","substring","decrement","readError","fileError","item","entry","isFile","getAsFile","readDirectory","reader","readEntries","entries","isDirectory","createReader","custom","replace","preventEvents","found","assignBrowse","domNodes","attributes","Element","domNode","input","tagName","document","createElement","setAttribute","style","visibility","position","width","height","appendChild","click","e","assignDrop","unAssignDrop","removeEventListener","_shouldUploadNext","num","should","ret","started","i","totalDone","totalSize","addFile","fileList","getFromUniqueIdentifier","f","getSize","sizeDelta","main"],"mappings":"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","file":"../skylark-flowjs.js","sourcesContent":["define('skylark-flowjs/flowjs',[\r\n\t\"skylark-langx/skylark\"\r\n],function(skylark){\r\n\tvar itg = skylark.itg = skylark.itg || {};\r\n\r\n\treturn itg.flowjs = {};\r\n});\ndefine('skylark-flowjs/utils',[\r\n  \"skylark-langx/langx\",\r\n  \"./flowjs\"\r\n],function(langx,flowjs){\r\n\r\n  /**\r\n   * Remove value from array\r\n   * @param array\r\n   * @param value\r\n   */\r\n  function arrayRemove(array, value) {\r\n    var index = array.indexOf(value);\r\n    if (index > -1) {\r\n      array.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If option is a function, evaluate it with given params\r\n   * @param {*} data\r\n   * @param {...} args arguments of a callback\r\n   * @returns {*}\r\n   */\r\n  function evalOpts(data, args) {\r\n    if (typeof data === \"function\") {\r\n      // `arguments` is an object, not array, in FF, so:\r\n      args = Array.prototype.slice.call(arguments);\r\n      data = data.apply(null, args.slice(1));\r\n    }\r\n    return data;\r\n  }\r\n\r\n\r\n  /**\r\n   * Execute function asynchronously\r\n   * @param fn\r\n   * @param context\r\n   */\r\n  function async(fn, context) {\r\n    setTimeout(fn.bind(context), 0);\r\n  }\r\n\r\n  /**\r\n   * Extends the destination object `dst` by copying all of the properties from\r\n   * the `src` object(s) to `dst`. You can specify multiple `src` objects.\r\n   * @function\r\n   * @param {Object} dst Destination object.\r\n   * @param {...Object} src Source object(s).\r\n   * @returns {Object} Reference to `dst`.\r\n   */\r\n  function extend(dst, src) {\r\n    each(arguments, function(obj) {\r\n      if (obj !== dst) {\r\n        each(obj, function(value, key){\r\n          dst[key] = value;\r\n        });\r\n      }\r\n    });\r\n    return dst;\r\n  }\r\n\r\n  /**\r\n   * Iterate each element of an object\r\n   * @function\r\n   * @param {Array|Object} obj object or an array to iterate\r\n   * @param {Function} callback first argument is a value and second is a key.\r\n   * @param {Object=} context Object to become context (`this`) for the iterator function.\r\n   */\r\n  function each(obj, callback, context) {\r\n    if (!obj) {\r\n      return ;\r\n    }\r\n    var key;\r\n    // Is Array?\r\n    // Array.isArray won't work, not only arrays can be iterated by index https://github.com/flowjs/ng-flow/issues/236#\r\n    if (typeof(obj.length) !== 'undefined') {\r\n      for (key = 0; key < obj.length; key++) {\r\n        if (callback.call(context, obj[key], key) === false) {\r\n          return ;\r\n        }\r\n      }\r\n    } else {\r\n      for (key in obj) {\r\n        if (obj.hasOwnProperty(key) && callback.call(context, obj[key], key) === false) {\r\n          return ;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  return {\r\n  \tarrayRemove,\r\n  \tevalOpts,\r\n  \tasync,\r\n  \textend,\r\n  \teach\r\n  } ;\r\n\r\n});\ndefine('skylark-flowjs/FlowChunk',[\r\n  \"skylark-langx/langx\",\r\n  \"./flowjs\",\r\n \"./utils\"\r\n ],function(langx,flowjs,utils){\r\n  'use strict';\r\n\r\n  var each = utils.each,\r\n  \t  evalOpts = utils.evalOpts,\r\n  \t  extend = utils.extend;\r\n\r\n  /**\r\n   * Class for storing a single chunk\r\n   * @name FlowChunk\r\n   * @param {Flow} flowObj\r\n   * @param {FlowFile} fileObj\r\n   * @param {number} offset\r\n   * @constructor\r\n   */\r\n  function FlowChunk(flowObj, fileObj, offset) {\r\n\r\n    /**\r\n     * Reference to parent flow object\r\n     * @type {Flow}\r\n     */\r\n    this.flowObj = flowObj;\r\n\r\n    /**\r\n     * Reference to parent FlowFile object\r\n     * @type {FlowFile}\r\n     */\r\n    this.fileObj = fileObj;\r\n\r\n    /**\r\n     * File offset\r\n     * @type {number}\r\n     */\r\n    this.offset = offset;\r\n\r\n    /**\r\n     * Indicates if chunk existence was checked on the server\r\n     * @type {boolean}\r\n     */\r\n    this.tested = false;\r\n\r\n    /**\r\n     * Number of retries performed\r\n     * @type {number}\r\n     */\r\n    this.retries = 0;\r\n\r\n    /**\r\n     * Pending retry\r\n     * @type {boolean}\r\n     */\r\n    this.pendingRetry = false;\r\n\r\n    /**\r\n     * Preprocess state\r\n     * @type {number} 0 = unprocessed, 1 = processing, 2 = finished\r\n     */\r\n    this.preprocessState = 0;\r\n\r\n    /**\r\n     * Read state\r\n     * @type {number} 0 = not read, 1 = reading, 2 = finished\r\n     */\r\n    this.readState = 0;\r\n\r\n\r\n    /**\r\n     * Bytes transferred from total request size\r\n     * @type {number}\r\n     */\r\n    this.loaded = 0;\r\n\r\n    /**\r\n     * Total request size\r\n     * @type {number}\r\n     */\r\n    this.total = 0;\r\n\r\n    /**\r\n     * Size of a chunk\r\n     * @type {number}\r\n     */\r\n    this.chunkSize = this.flowObj.opts.chunkSize;\r\n\r\n    /**\r\n     * Chunk start byte in a file\r\n     * @type {number}\r\n     */\r\n    this.startByte = this.offset * this.chunkSize;\r\n\r\n    /**\r\n      * Compute the endbyte in a file\r\n      *\r\n      */\r\n    this.computeEndByte = function() {\r\n      var endByte = Math.min(this.fileObj.size, (this.offset + 1) * this.chunkSize);\r\n      if (this.fileObj.size - endByte < this.chunkSize && !this.flowObj.opts.forceChunkSize) {\r\n        // The last chunk will be bigger than the chunk size,\r\n        // but less than 2 * this.chunkSize\r\n        endByte = this.fileObj.size;\r\n      }\r\n      return endByte;\r\n    }\r\n\r\n    /**\r\n     * Chunk end byte in a file\r\n     * @type {number}\r\n     */\r\n    this.endByte = this.computeEndByte();\r\n\r\n    /**\r\n     * XMLHttpRequest\r\n     * @type {XMLHttpRequest}\r\n     */\r\n    this.xhr = null;\r\n\r\n    var $ = this;\r\n\r\n    /**\r\n     * Send chunk event\r\n     * @param event\r\n     * @param {...} args arguments of a callback\r\n     */\r\n    this.event = function (event, args) {\r\n      args = Array.prototype.slice.call(arguments);\r\n      args.unshift($);\r\n      $.fileObj.chunkEvent.apply($.fileObj, args);\r\n    };\r\n    /**\r\n     * Catch progress event\r\n     * @param {ProgressEvent} event\r\n     */\r\n    this.progressHandler = function(event) {\r\n      if (event.lengthComputable) {\r\n        $.loaded = event.loaded ;\r\n        $.total = event.total;\r\n      }\r\n      $.event('progress', event);\r\n    };\r\n\r\n    /**\r\n     * Catch test event\r\n     * @param {Event} event\r\n     */\r\n    this.testHandler = function(event) {\r\n      var status = $.status(true);\r\n      if (status === 'error') {\r\n        $.event(status, $.message());\r\n        $.flowObj.uploadNextChunk();\r\n      } else if (status === 'success') {\r\n        $.tested = true;\r\n        $.event(status, $.message());\r\n        $.flowObj.uploadNextChunk();\r\n      } else if (!$.fileObj.paused) {\r\n        // Error might be caused by file pause method\r\n        // Chunks does not exist on the server side\r\n        $.tested = true;\r\n        $.send();\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Upload has stopped\r\n     * @param {Event} event\r\n     */\r\n    this.doneHandler = function(event) {\r\n      var status = $.status();\r\n      if (status === 'success' || status === 'error') {\r\n        delete this.data;\r\n        $.event(status, $.message());\r\n        $.flowObj.uploadNextChunk();\r\n      } else {\r\n        $.event('retry', $.message());\r\n        $.pendingRetry = true;\r\n        $.abort();\r\n        $.retries++;\r\n        var retryInterval = $.flowObj.opts.chunkRetryInterval;\r\n        if (retryInterval !== null) {\r\n          setTimeout(function () {\r\n            $.send();\r\n          }, retryInterval);\r\n        } else {\r\n          $.send();\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  FlowChunk.prototype = {\r\n    /**\r\n     * Get params for a request\r\n     * @function\r\n     */\r\n    getParams: function () {\r\n      return {\r\n        flowChunkNumber: this.offset + 1,\r\n        flowChunkSize: this.flowObj.opts.chunkSize,\r\n        flowCurrentChunkSize: this.endByte - this.startByte,\r\n        flowTotalSize: this.fileObj.size,\r\n        flowIdentifier: this.fileObj.uniqueIdentifier,\r\n        flowFilename: this.fileObj.name,\r\n        flowRelativePath: this.fileObj.relativePath,\r\n        flowTotalChunks: this.fileObj.chunks.length\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Get target option with query params\r\n     * @function\r\n     * @param params\r\n     * @returns {string}\r\n     */\r\n    getTarget: function(target, params){\r\n      if(target.indexOf('?') < 0) {\r\n        target += '?';\r\n      } else {\r\n        target += '&';\r\n      }\r\n      return target + params.join('&');\r\n    },\r\n\r\n    /**\r\n     * Makes a GET request without any data to see if the chunk has already\r\n     * been uploaded in a previous session\r\n     * @function\r\n     */\r\n    test: function () {\r\n      // Set up request and listen for event\r\n      this.xhr = new XMLHttpRequest();\r\n      this.xhr.addEventListener(\"load\", this.testHandler, false);\r\n      this.xhr.addEventListener(\"error\", this.testHandler, false);\r\n      var testMethod = evalOpts(this.flowObj.opts.testMethod, this.fileObj, this);\r\n      var data = this.prepareXhrRequest(testMethod, true);\r\n      this.xhr.send(data);\r\n    },\r\n\r\n    /**\r\n     * Finish preprocess state\r\n     * @function\r\n     */\r\n    preprocessFinished: function () {\r\n      // Re-compute the endByte after the preprocess function to allow an\r\n      // implementer of preprocess to set the fileObj size\r\n      this.endByte = this.computeEndByte();\r\n\r\n      this.preprocessState = 2;\r\n      this.send();\r\n    },\r\n\r\n    /**\r\n     * Finish read state\r\n     * @function\r\n     */\r\n    readFinished: function (bytes) {\r\n      this.readState = 2;\r\n      this.bytes = bytes;\r\n      this.send();\r\n    },\r\n\r\n\r\n    /**\r\n     * Uploads the actual data in a POST call\r\n     * @function\r\n     */\r\n    send: function () {\r\n      var preprocess = this.flowObj.opts.preprocess;\r\n      var read = this.flowObj.opts.readFileFn;\r\n      if (typeof preprocess === 'function') {\r\n        switch (this.preprocessState) {\r\n          case 0:\r\n            this.preprocessState = 1;\r\n            preprocess(this);\r\n            return;\r\n          case 1:\r\n            return;\r\n        }\r\n      }\r\n      switch (this.readState) {\r\n        case 0:\r\n          this.readState = 1;\r\n          read(this.fileObj, this.startByte, this.endByte, this.fileObj.file.type, this);\r\n          return;\r\n        case 1:\r\n          return;\r\n      }\r\n      if (this.flowObj.opts.testChunks && !this.tested) {\r\n        this.test();\r\n        return;\r\n      }\r\n\r\n      this.loaded = 0;\r\n      this.total = 0;\r\n      this.pendingRetry = false;\r\n\r\n      // Set up request and listen for event\r\n      this.xhr = new XMLHttpRequest();\r\n      this.xhr.upload.addEventListener('progress', this.progressHandler, false);\r\n      this.xhr.addEventListener(\"load\", this.doneHandler, false);\r\n      this.xhr.addEventListener(\"error\", this.doneHandler, false);\r\n\r\n      var uploadMethod = evalOpts(this.flowObj.opts.uploadMethod, this.fileObj, this);\r\n      var data = this.prepareXhrRequest(uploadMethod, false, this.flowObj.opts.method, this.bytes);\r\n      this.xhr.send(data);\r\n    },\r\n\r\n    /**\r\n     * Abort current xhr request\r\n     * @function\r\n     */\r\n    abort: function () {\r\n      // Abort and reset\r\n      var xhr = this.xhr;\r\n      this.xhr = null;\r\n      if (xhr) {\r\n        xhr.abort();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Retrieve current chunk upload status\r\n     * @function\r\n     * @returns {string} 'pending', 'uploading', 'success', 'error'\r\n     */\r\n    status: function (isTest) {\r\n      if (this.readState === 1) {\r\n        return 'reading';\r\n      } else if (this.pendingRetry || this.preprocessState === 1) {\r\n        // if pending retry then that's effectively the same as actively uploading,\r\n        // there might just be a slight delay before the retry starts\r\n        return 'uploading';\r\n      } else if (!this.xhr) {\r\n        return 'pending';\r\n      } else if (this.xhr.readyState < 4) {\r\n        // Status is really 'OPENED', 'HEADERS_RECEIVED'\r\n        // or 'LOADING' - meaning that stuff is happening\r\n        return 'uploading';\r\n      } else {\r\n        if (this.flowObj.opts.successStatuses.indexOf(this.xhr.status) > -1) {\r\n          // HTTP 200, perfect\r\n\t\t      // HTTP 202 Accepted - The request has been accepted for processing, but the processing has not been completed.\r\n          return 'success';\r\n        } else if (this.flowObj.opts.permanentErrors.indexOf(this.xhr.status) > -1 ||\r\n            !isTest && this.retries >= this.flowObj.opts.maxChunkRetries) {\r\n          // HTTP 413/415/500/501, permanent error\r\n          return 'error';\r\n        } else {\r\n          // this should never happen, but we'll reset and queue a retry\r\n          // a likely case for this would be 503 service unavailable\r\n          this.abort();\r\n          return 'pending';\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Get response from xhr request\r\n     * @function\r\n     * @returns {String}\r\n     */\r\n    message: function () {\r\n      return this.xhr ? this.xhr.responseText : '';\r\n    },\r\n\r\n    /**\r\n     * Get upload progress\r\n     * @function\r\n     * @returns {number}\r\n     */\r\n    progress: function () {\r\n      if (this.pendingRetry) {\r\n        return 0;\r\n      }\r\n      var s = this.status();\r\n      if (s === 'success' || s === 'error') {\r\n        return 1;\r\n      } else if (s === 'pending') {\r\n        return 0;\r\n      } else {\r\n        return this.total > 0 ? this.loaded / this.total : 0;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Count total size uploaded\r\n     * @function\r\n     * @returns {number}\r\n     */\r\n    sizeUploaded: function () {\r\n      var size = this.endByte - this.startByte;\r\n      // can't return only chunk.loaded value, because it is bigger than chunk size\r\n      if (this.status() !== 'success') {\r\n        size = this.progress() * size;\r\n      }\r\n      return size;\r\n    },\r\n\r\n    /**\r\n     * Prepare Xhr request. Set query, headers and data\r\n     * @param {string} method GET or POST\r\n     * @param {bool} isTest is this a test request\r\n     * @param {string} [paramsMethod] octet or form\r\n     * @param {Blob} [blob] to send\r\n     * @returns {FormData|Blob|Null} data to send\r\n     */\r\n    prepareXhrRequest: function(method, isTest, paramsMethod, blob) {\r\n      // Add data from the query options\r\n      var query = evalOpts(this.flowObj.opts.query, this.fileObj, this, isTest);\r\n      query = extend(query || {}, this.getParams());\r\n\r\n      var target = evalOpts(this.flowObj.opts.target, this.fileObj, this, isTest);\r\n      var data = null;\r\n      if (method === 'GET' || paramsMethod === 'octet') {\r\n        // Add data from the query options\r\n        var params = [];\r\n        each(query, function (v, k) {\r\n          params.push([encodeURIComponent(k), encodeURIComponent(v)].join('='));\r\n        });\r\n        target = this.getTarget(target, params);\r\n        data = blob || null;\r\n      } else {\r\n        // Add data from the query options\r\n        data = new FormData();\r\n        each(query, function (v, k) {\r\n          data.append(k, v);\r\n        });\r\n        if (typeof blob !== \"undefined\") data.append(this.flowObj.opts.fileParameterName, blob, this.fileObj.file.name);\r\n      }\r\n\r\n      this.xhr.open(method, target, true);\r\n      this.xhr.withCredentials = this.flowObj.opts.withCredentials;\r\n\r\n      // Add data from header options\r\n      each(evalOpts(this.flowObj.opts.headers, this.fileObj, this, isTest), function (v, k) {\r\n        this.xhr.setRequestHeader(k, v);\r\n      }, this);\r\n\r\n      return data;\r\n    }\r\n  };\r\n\r\n  return flowjs.FlowChunk = FlowChunk;\r\n\r\n});\ndefine('skylark-flowjs/FlowFile',[\r\n  \"skylark-langx/langx\",\r\n  \"./flowjs\",\r\n  \"./utils\",\r\n  \"./FlowChunk\"\r\n],function(langx,flowjs,utils,FlowChunk){\r\n  'use strict';\r\n\r\n  var each = utils.each;\r\n\r\n  /**\r\n   * FlowFile class\r\n   * @name FlowFile\r\n   * @param {Flow} flowObj\r\n   * @param {File} file\r\n   * @param {string} uniqueIdentifier\r\n   * @constructor\r\n   */\r\n  function FlowFile(flowObj, file, uniqueIdentifier) {\r\n\r\n    /**\r\n     * Reference to parent Flow instance\r\n     * @type {Flow}\r\n     */\r\n    this.flowObj = flowObj;\r\n\r\n    /**\r\n     * Used to store the bytes read\r\n     * @type {Blob|string}\r\n     */\r\n    this.bytes = null;\r\n\r\n    /**\r\n     * Reference to file\r\n     * @type {File}\r\n     */\r\n    this.file = file;\r\n\r\n    /**\r\n     * File name. Some confusion in different versions of Firefox\r\n     * @type {string}\r\n     */\r\n    this.name = file.fileName || file.name;\r\n\r\n    /**\r\n     * File size\r\n     * @type {number}\r\n     */\r\n    this.size = file.size;\r\n\r\n    /**\r\n     * Relative file path\r\n     * @type {string}\r\n     */\r\n    this.relativePath = file.relativePath || file.webkitRelativePath || this.name;\r\n\r\n    /**\r\n     * File unique identifier\r\n     * @type {string}\r\n     */\r\n    this.uniqueIdentifier = (uniqueIdentifier === undefined ? flowObj.generateUniqueIdentifier(file) : uniqueIdentifier);\r\n\r\n    /**\r\n     * List of chunks\r\n     * @type {Array.<FlowChunk>}\r\n     */\r\n    this.chunks = [];\r\n\r\n    /**\r\n     * Indicated if file is paused\r\n     * @type {boolean}\r\n     */\r\n    this.paused = false;\r\n\r\n    /**\r\n     * Indicated if file has encountered an error\r\n     * @type {boolean}\r\n     */\r\n    this.error = false;\r\n\r\n    /**\r\n     * Average upload speed\r\n     * @type {number}\r\n     */\r\n    this.averageSpeed = 0;\r\n\r\n    /**\r\n     * Current upload speed\r\n     * @type {number}\r\n     */\r\n    this.currentSpeed = 0;\r\n\r\n    /**\r\n     * Date then progress was called last time\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this._lastProgressCallback = Date.now();\r\n\r\n    /**\r\n     * Previously uploaded file size\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this._prevUploadedSize = 0;\r\n\r\n    /**\r\n     * Holds previous progress\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this._prevProgress = 0;\r\n\r\n    this.bootstrap();\r\n  }\r\n\r\n  FlowFile.prototype = {\r\n    /**\r\n     * Update speed parameters\r\n     * @link http://stackoverflow.com/questions/2779600/how-to-estimate-download-time-remaining-accurately\r\n     * @function\r\n     */\r\n    measureSpeed: function () {\r\n      var timeSpan = Date.now() - this._lastProgressCallback;\r\n      if (!timeSpan) {\r\n        return ;\r\n      }\r\n      var smoothingFactor = this.flowObj.opts.speedSmoothingFactor;\r\n      var uploaded = this.sizeUploaded();\r\n      // Prevent negative upload speed after file upload resume\r\n      this.currentSpeed = Math.max((uploaded - this._prevUploadedSize) / timeSpan * 1000, 0);\r\n      this.averageSpeed = smoothingFactor * this.currentSpeed + (1 - smoothingFactor) * this.averageSpeed;\r\n      this._prevUploadedSize = uploaded;\r\n    },\r\n\r\n    /**\r\n     * For internal usage only.\r\n     * Callback when something happens within the chunk.\r\n     * @function\r\n     * @param {FlowChunk} chunk\r\n     * @param {string} event can be 'progress', 'success', 'error' or 'retry'\r\n     * @param {string} [message]\r\n     */\r\n    chunkEvent: function (chunk, event, message) {\r\n      switch (event) {\r\n        case 'progress':\r\n          if (Date.now() - this._lastProgressCallback <\r\n            this.flowObj.opts.progressCallbacksInterval) {\r\n            break;\r\n          }\r\n          this.measureSpeed();\r\n          this.flowObj.fire('fileProgress', this, chunk);\r\n          this.flowObj.fire('progress');\r\n          this._lastProgressCallback = Date.now();\r\n          break;\r\n        case 'error':\r\n          this.error = true;\r\n          this.abort(true);\r\n          this.flowObj.fire('fileError', this, message, chunk);\r\n          this.flowObj.fire('error', message, this, chunk);\r\n          break;\r\n        case 'success':\r\n          if (this.error) {\r\n            return;\r\n          }\r\n          this.measureSpeed();\r\n          this.flowObj.fire('fileProgress', this, chunk);\r\n          this.flowObj.fire('progress');\r\n          this._lastProgressCallback = Date.now();\r\n          if (this.isComplete()) {\r\n            this.currentSpeed = 0;\r\n            this.averageSpeed = 0;\r\n            this.flowObj.fire('fileSuccess', this, message, chunk);\r\n          }\r\n          break;\r\n        case 'retry':\r\n          this.flowObj.fire('fileRetry', this, chunk);\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Pause file upload\r\n     * @function\r\n     */\r\n    pause: function() {\r\n      this.paused = true;\r\n      this.abort();\r\n    },\r\n\r\n    /**\r\n     * Resume file upload\r\n     * @function\r\n     */\r\n    resume: function() {\r\n      this.paused = false;\r\n      this.flowObj.upload();\r\n    },\r\n\r\n    /**\r\n     * Abort current upload\r\n     * @function\r\n     */\r\n    abort: function (reset) {\r\n      this.currentSpeed = 0;\r\n      this.averageSpeed = 0;\r\n      var chunks = this.chunks;\r\n      if (reset) {\r\n        this.chunks = [];\r\n      }\r\n      each(chunks, function (c) {\r\n        if (c.status() === 'uploading') {\r\n          c.abort();\r\n          this.flowObj.uploadNextChunk();\r\n        }\r\n      }, this);\r\n    },\r\n\r\n    /**\r\n     * Cancel current upload and remove from a list\r\n     * @function\r\n     */\r\n    cancel: function () {\r\n      this.flowObj.removeFile(this);\r\n    },\r\n\r\n    /**\r\n     * Retry aborted file upload\r\n     * @function\r\n     */\r\n    retry: function () {\r\n      this.bootstrap();\r\n      this.flowObj.upload();\r\n    },\r\n\r\n    /**\r\n     * Clear current chunks and slice file again\r\n     * @function\r\n     */\r\n    bootstrap: function () {\r\n      if (typeof this.flowObj.opts.initFileFn === \"function\") {\r\n        this.flowObj.opts.initFileFn(this);\r\n      }\r\n\r\n      this.abort(true);\r\n      this.error = false;\r\n      // Rebuild stack of chunks from file\r\n      this._prevProgress = 0;\r\n      var round = this.flowObj.opts.forceChunkSize ? Math.ceil : Math.floor;\r\n      var chunks = Math.max(\r\n        round(this.size / this.flowObj.opts.chunkSize), 1\r\n      );\r\n      for (var offset = 0; offset < chunks; offset++) {\r\n        this.chunks.push(\r\n          new FlowChunk(this.flowObj, this, offset)\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Get current upload progress status\r\n     * @function\r\n     * @returns {number} from 0 to 1\r\n     */\r\n    progress: function () {\r\n      if (this.error) {\r\n        return 1;\r\n      }\r\n      if (this.chunks.length === 1) {\r\n        this._prevProgress = Math.max(this._prevProgress, this.chunks[0].progress());\r\n        return this._prevProgress;\r\n      }\r\n      // Sum up progress across everything\r\n      var bytesLoaded = 0;\r\n      each(this.chunks, function (c) {\r\n        // get chunk progress relative to entire file\r\n        bytesLoaded += c.progress() * (c.endByte - c.startByte);\r\n      });\r\n      var percent = bytesLoaded / this.size;\r\n      // We don't want to lose percentages when an upload is paused\r\n      this._prevProgress = Math.max(this._prevProgress, percent > 0.9999 ? 1 : percent);\r\n      return this._prevProgress;\r\n    },\r\n\r\n    /**\r\n     * Indicates if file is being uploaded at the moment\r\n     * @function\r\n     * @returns {boolean}\r\n     */\r\n    isUploading: function () {\r\n      var uploading = false;\r\n      each(this.chunks, function (chunk) {\r\n        if (chunk.status() === 'uploading') {\r\n          uploading = true;\r\n          return false;\r\n        }\r\n      });\r\n      return uploading;\r\n    },\r\n\r\n    /**\r\n     * Indicates if file is has finished uploading and received a response\r\n     * @function\r\n     * @returns {boolean}\r\n     */\r\n    isComplete: function () {\r\n      var outstanding = false;\r\n      each(this.chunks, function (chunk) {\r\n        var status = chunk.status();\r\n        if (status === 'pending' || status === 'uploading' || status === 'reading' || chunk.preprocessState === 1 || chunk.readState === 1) {\r\n          outstanding = true;\r\n          return false;\r\n        }\r\n      });\r\n      return !outstanding;\r\n    },\r\n\r\n    /**\r\n     * Count total size uploaded\r\n     * @function\r\n     * @returns {number}\r\n     */\r\n    sizeUploaded: function () {\r\n      var size = 0;\r\n      each(this.chunks, function (chunk) {\r\n        size += chunk.sizeUploaded();\r\n      });\r\n      return size;\r\n    },\r\n\r\n    /**\r\n     * Returns remaining time to finish upload file in seconds. Accuracy is based on average speed.\r\n     * If speed is zero, time remaining will be equal to positive infinity `Number.POSITIVE_INFINITY`\r\n     * @function\r\n     * @returns {number}\r\n     */\r\n    timeRemaining: function () {\r\n      if (this.paused || this.error) {\r\n        return 0;\r\n      }\r\n      var delta = this.size - this.sizeUploaded();\r\n      if (delta && !this.averageSpeed) {\r\n        return Number.POSITIVE_INFINITY;\r\n      }\r\n      if (!delta && !this.averageSpeed) {\r\n        return 0;\r\n      }\r\n      return Math.floor(delta / this.averageSpeed);\r\n    },\r\n\r\n    /**\r\n     * Get file type\r\n     * @function\r\n     * @returns {string}\r\n     */\r\n    getType: function () {\r\n      return this.file.type && this.file.type.split('/')[1];\r\n    },\r\n\r\n    /**\r\n     * Get file extension\r\n     * @function\r\n     * @returns {string}\r\n     */\r\n    getExtension: function () {\r\n      return this.name.substr((~-this.name.lastIndexOf(\".\") >>> 0) + 2).toLowerCase();\r\n    }\r\n  };\r\n\t\r\n\r\n  return flowjs.FlowFile = FlowFile;\r\n});\ndefine('skylark-flowjs/Flow',[\n  \"skylark-langx/langx\",\n  \"./flowjs\",\n  \"./utils\",\n  \"./FlowFile\"\n],function(langx,flowjs,utils,FlowFile){\n\n  'use strict';\n\n  var each = utils.each,\n      async = utils.async,\n      extend = utils.extend,\n      arrayRemove = utils.arrayRemove;\n\n  // ie10+\n  var ie10plus = window.navigator.msPointerEnabled;\n  /**\n   * Flow.js is a library providing multiple simultaneous, stable and\n   * resumable uploads via the HTML5 File API.\n   * @param [opts]\n   * @param {number} [opts.chunkSize]\n   * @param {bool} [opts.forceChunkSize]\n   * @param {number} [opts.simultaneousUploads]\n   * @param {bool} [opts.singleFile]\n   * @param {string} [opts.fileParameterName]\n   * @param {number} [opts.progressCallbacksInterval]\n   * @param {number} [opts.speedSmoothingFactor]\n   * @param {Object|Function} [opts.query]\n   * @param {Object|Function} [opts.headers]\n   * @param {bool} [opts.withCredentials]\n   * @param {Function} [opts.preprocess]\n   * @param {string} [opts.method]\n   * @param {string|Function} [opts.testMethod]\n   * @param {string|Function} [opts.uploadMethod]\n   * @param {bool} [opts.prioritizeFirstAndLastChunk]\n   * @param {bool} [opts.allowDuplicateUploads]\n   * @param {string|Function} [opts.target]\n   * @param {number} [opts.maxChunkRetries]\n   * @param {number} [opts.chunkRetryInterval]\n   * @param {Array.<number>} [opts.permanentErrors]\n   * @param {Array.<number>} [opts.successStatuses]\n   * @param {Function} [opts.initFileFn]\n   * @param {Function} [opts.readFileFn]\n   * @param {Function} [opts.generateUniqueIdentifier]\n   * @constructor\n   */\n  function Flow(opts) {\n    /**\n     * Supported by browser?\n     * @type {boolean}\n     */\n    this.support = (\n        typeof File !== 'undefined' &&\n        typeof Blob !== 'undefined' &&\n        typeof FileList !== 'undefined' &&\n        (\n          !!Blob.prototype.slice || !!Blob.prototype.webkitSlice || !!Blob.prototype.mozSlice ||\n          false\n        ) // slicing files support\n    );\n\n    if (!this.support) {\n      return ;\n    }\n\n    /**\n     * Check if directory upload is supported\n     * @type {boolean}\n     */\n    this.supportDirectory = (\n        /Chrome/.test(window.navigator.userAgent) ||\n        /Firefox/.test(window.navigator.userAgent) ||\n        /Edge/.test(window.navigator.userAgent)\n    );\n\n    /**\n     * List of FlowFile objects\n     * @type {Array.<FlowFile>}\n     */\n    this.files = [];\n\n    /**\n     * Default options for flow.js\n     * @type {Object}\n     */\n    this.defaults = {\n      chunkSize: 1024 * 1024,\n      forceChunkSize: false,\n      simultaneousUploads: 3,\n      singleFile: false,\n      fileParameterName: 'file',\n      progressCallbacksInterval: 500,\n      speedSmoothingFactor: 0.1,\n      query: {},\n      headers: {},\n      withCredentials: false,\n      preprocess: null,\n      method: 'multipart',\n      testMethod: 'GET',\n      uploadMethod: 'POST',\n      prioritizeFirstAndLastChunk: false,\n      allowDuplicateUploads: false,\n      target: '/',\n      testChunks: true,\n      generateUniqueIdentifier: null,\n      maxChunkRetries: 0,\n      chunkRetryInterval: null,\n      permanentErrors: [404, 413, 415, 500, 501],\n      successStatuses: [200, 201, 202],\n      onDropStopPropagation: false,\n      initFileFn: null,\n      readFileFn: webAPIFileRead\n    };\n\n    /**\n     * Current options\n     * @type {Object}\n     */\n    this.opts = {};\n\n    /**\n     * List of events:\n     *  key stands for event name\n     *  value array list of callbacks\n     * @type {}\n     */\n    this.events = {};\n\n    var $ = this;\n\n    /**\n     * On drop event\n     * @function\n     * @param {MouseEvent} event\n     */\n    this.onDrop = function (event) {\n      if ($.opts.onDropStopPropagation) {\n        event.stopPropagation();\n      }\n      event.preventDefault();\n      var dataTransfer = event.dataTransfer;\n      if (dataTransfer.items && dataTransfer.items[0] &&\n        dataTransfer.items[0].webkitGetAsEntry) {\n        $.webkitReadDataTransfer(event);\n      } else {\n        $.addFiles(dataTransfer.files, event);\n      }\n    };\n\n    /**\n     * Prevent default\n     * @function\n     * @param {MouseEvent} event\n     */\n    this.preventEvent = function (event) {\n      event.preventDefault();\n    };\n\n\n    /**\n     * Current options\n     * @type {Object}\n     */\n    this.opts = extend({}, this.defaults, opts || {});\n\n  }\n\n  Flow.prototype = {\n    /**\n     * Set a callback for an event, possible events:\n     * fileSuccess(file), fileProgress(file), fileAdded(file, event),\n     * fileRemoved(file), fileRetry(file), fileError(file, message),\n     * complete(), progress(), error(message, file), pause()\n     * @function\n     * @param {string} event\n     * @param {Function} callback\n     */\n    on: function (event, callback) {\n      event = event.toLowerCase();\n      if (!this.events.hasOwnProperty(event)) {\n        this.events[event] = [];\n      }\n      this.events[event].push(callback);\n    },\n\n    /**\n     * Remove event callback\n     * @function\n     * @param {string} [event] removes all events if not specified\n     * @param {Function} [fn] removes all callbacks of event if not specified\n     */\n    off: function (event, fn) {\n      if (event !== undefined) {\n        event = event.toLowerCase();\n        if (fn !== undefined) {\n          if (this.events.hasOwnProperty(event)) {\n            arrayRemove(this.events[event], fn);\n          }\n        } else {\n          delete this.events[event];\n        }\n      } else {\n        this.events = {};\n      }\n    },\n\n    /**\n     * Fire an event\n     * @function\n     * @param {string} event event name\n     * @param {...} args arguments of a callback\n     * @return {bool} value is false if at least one of the event handlers which handled this event\n     * returned false. Otherwise it returns true.\n     */\n    fire: function (event, args) {\n      // `arguments` is an object, not array, in FF, so:\n      args = Array.prototype.slice.call(arguments);\n      event = event.toLowerCase();\n      var preventDefault = false;\n      if (this.events.hasOwnProperty(event)) {\n        each(this.events[event], function (callback) {\n          preventDefault = callback.apply(this, args.slice(1)) === false || preventDefault;\n        }, this);\n      }\n      if (event != 'catchall') {\n        args.unshift('catchAll');\n        preventDefault = this.fire.apply(this, args) === false || preventDefault;\n      }\n      return !preventDefault;\n    },\n\n    /**\n     * Read webkit dataTransfer object\n     * @param event\n     */\n    webkitReadDataTransfer: function (event) {\n      var $ = this;\n      var queue = event.dataTransfer.items.length;\n      var files = [];\n      each(event.dataTransfer.items, function (item) {\n        var entry = item.webkitGetAsEntry();\n        if (!entry) {\n          decrement();\n          return ;\n        }\n        if (entry.isFile) {\n          // due to a bug in Chrome's File System API impl - #149735\n          fileReadSuccess(item.getAsFile(), entry.fullPath);\n        } else {\n          readDirectory(entry.createReader());\n        }\n      });\n      function readDirectory(reader) {\n        reader.readEntries(function (entries) {\n          if (entries.length) {\n            queue += entries.length;\n            each(entries, function(entry) {\n              if (entry.isFile) {\n                var fullPath = entry.fullPath;\n                entry.file(function (file) {\n                  fileReadSuccess(file, fullPath);\n                }, readError);\n              } else if (entry.isDirectory) {\n                readDirectory(entry.createReader());\n              }\n            });\n            readDirectory(reader);\n          } else {\n            decrement();\n          }\n        }, readError);\n      }\n      function fileReadSuccess(file, fullPath) {\n        // relative path should not start with \"/\"\n        file.relativePath = fullPath.substring(1);\n        files.push(file);\n        decrement();\n      }\n      function readError(fileError) {\n        throw fileError;\n      }\n      function decrement() {\n        if (--queue == 0) {\n          $.addFiles(files, event);\n        }\n      }\n    },\n\n    /**\n     * Generate unique identifier for a file\n     * @function\n     * @param {FlowFile} file\n     * @returns {string}\n     */\n    generateUniqueIdentifier: function (file) {\n      var custom = this.opts.generateUniqueIdentifier;\n      if (typeof custom === 'function') {\n        return custom(file);\n      }\n      // Some confusion in different versions of Firefox\n      var relativePath = file.relativePath || file.webkitRelativePath || file.fileName || file.name;\n      return file.size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, '');\n    },\n\n    /**\n     * Upload next chunk from the queue\n     * @function\n     * @returns {boolean}\n     * @private\n     */\n    uploadNextChunk: function (preventEvents) {\n      // In some cases (such as videos) it's really handy to upload the first\n      // and last chunk of a file quickly; this let's the server check the file's\n      // metadata and determine if there's even a point in continuing.\n      var found = false;\n      if (this.opts.prioritizeFirstAndLastChunk) {\n        each(this.files, function (file) {\n          if (!file.paused && file.chunks.length &&\n            file.chunks[0].status() === 'pending') {\n            file.chunks[0].send();\n            found = true;\n            return false;\n          }\n          if (!file.paused && file.chunks.length > 1 &&\n            file.chunks[file.chunks.length - 1].status() === 'pending') {\n            file.chunks[file.chunks.length - 1].send();\n            found = true;\n            return false;\n          }\n        });\n        if (found) {\n          return found;\n        }\n      }\n\n      // Now, simply look for the next, best thing to upload\n      each(this.files, function (file) {\n        if (!file.paused) {\n          each(file.chunks, function (chunk) {\n            if (chunk.status() === 'pending') {\n              chunk.send();\n              found = true;\n              return false;\n            }\n          });\n        }\n        if (found) {\n          return false;\n        }\n      });\n      if (found) {\n        return true;\n      }\n\n      // The are no more outstanding chunks to upload, check is everything is done\n      var outstanding = false;\n      each(this.files, function (file) {\n        if (!file.isComplete()) {\n          outstanding = true;\n          return false;\n        }\n      });\n      if (!outstanding && !preventEvents) {\n        // All chunks have been uploaded, complete\n        async(function () {\n          this.fire('complete');\n        }, this);\n      }\n      return false;\n    },\n\n\n    /**\n     * Assign a browse action to one or more DOM nodes.\n     * @function\n     * @param {Element|Array.<Element>} domNodes\n     * @param {boolean} isDirectory Pass in true to allow directories to\n     * @param {boolean} singleFile prevent multi file upload\n     * @param {Object} attributes set custom attributes:\n     *  http://www.w3.org/TR/html-markup/input.file.html#input.file-attributes\n     *  eg: accept: 'image/*'\n     * be selected (Chrome only).\n     */\n    assignBrowse: function (domNodes, isDirectory, singleFile, attributes) {\n      if (domNodes instanceof Element) {\n        domNodes = [domNodes];\n      }\n\n      each(domNodes, function (domNode) {\n        var input;\n        if (domNode.tagName === 'INPUT' && domNode.type === 'file') {\n          input = domNode;\n        } else {\n          input = document.createElement('input');\n          input.setAttribute('type', 'file');\n          // display:none - not working in opera 12\n          extend(input.style, {\n            visibility: 'hidden',\n            position: 'absolute',\n            width: '1px',\n            height: '1px'\n          });\n          // for opera 12 browser, input must be assigned to a document\n          domNode.appendChild(input);\n          // https://developer.mozilla.org/en/using_files_from_web_applications)\n          // event listener is executed two times\n          // first one - original mouse click event\n          // second - input.click(), input is inside domNode\n          domNode.addEventListener('click', function() {\n            input.click();\n          }, false);\n        }\n        if (!this.opts.singleFile && !singleFile) {\n          input.setAttribute('multiple', 'multiple');\n        }\n        if (isDirectory) {\n          input.setAttribute('webkitdirectory', 'webkitdirectory');\n        }\n        each(attributes, function (value, key) {\n          input.setAttribute(key, value);\n        });\n        // When new files are added, simply append them to the overall list\n        var $ = this;\n        input.addEventListener('change', function (e) {\n       \t  if (e.target.value) {\n            $.addFiles(e.target.files, e);\n            e.target.value = '';\n       \t  }\n        }, false);\n      }, this);\n    },\n\n    /**\n     * Assign one or more DOM nodes as a drop target.\n     * @function\n     * @param {Element|Array.<Element>} domNodes\n     */\n    assignDrop: function (domNodes) {\n      if (typeof domNodes.length === 'undefined') {\n        domNodes = [domNodes];\n      }\n      each(domNodes, function (domNode) {\n        domNode.addEventListener('dragover', this.preventEvent, false);\n        domNode.addEventListener('dragenter', this.preventEvent, false);\n        domNode.addEventListener('drop', this.onDrop, false);\n      }, this);\n    },\n\n    /**\n     * Un-assign drop event from DOM nodes\n     * @function\n     * @param domNodes\n     */\n    unAssignDrop: function (domNodes) {\n      if (typeof domNodes.length === 'undefined') {\n        domNodes = [domNodes];\n      }\n      each(domNodes, function (domNode) {\n        domNode.removeEventListener('dragover', this.preventEvent);\n        domNode.removeEventListener('dragenter', this.preventEvent);\n        domNode.removeEventListener('drop', this.onDrop);\n      }, this);\n    },\n\n    /**\n     * Returns a boolean indicating whether or not the instance is currently\n     * uploading anything.\n     * @function\n     * @returns {boolean}\n     */\n    isUploading: function () {\n      var uploading = false;\n      each(this.files, function (file) {\n        if (file.isUploading()) {\n          uploading = true;\n          return false;\n        }\n      });\n      return uploading;\n    },\n\n    /**\n     * should upload next chunk\n     * @function\n     * @returns {boolean|number}\n     */\n    _shouldUploadNext: function () {\n      var num = 0;\n      var should = true;\n      var simultaneousUploads = this.opts.simultaneousUploads;\n      each(this.files, function (file) {\n        each(file.chunks, function(chunk) {\n          if (chunk.status() === 'uploading') {\n            num++;\n            if (num >= simultaneousUploads) {\n              should = false;\n              return false;\n            }\n          }\n        });\n      });\n      // if should is true then return uploading chunks's length\n      return should && num;\n    },\n\n    /**\n     * Start or resume uploading.\n     * @function\n     */\n    upload: function () {\n      // Make sure we don't start too many uploads at once\n      var ret = this._shouldUploadNext();\n      if (ret === false) {\n        return;\n      }\n      // Kick off the queue\n      this.fire('uploadStart');\n      var started = false;\n      for (var num = 1; num <= this.opts.simultaneousUploads - ret; num++) {\n        started = this.uploadNextChunk(true) || started;\n      }\n      if (!started) {\n        async(function () {\n          this.fire('complete');\n        }, this);\n      }\n    },\n\n    /**\n     * Resume uploading.\n     * @function\n     */\n    resume: function () {\n      each(this.files, function (file) {\n        if (!file.isComplete()) {\n          file.resume();\n        }\n      });\n    },\n\n    /**\n     * Pause uploading.\n     * @function\n     */\n    pause: function () {\n      each(this.files, function (file) {\n        file.pause();\n      });\n    },\n\n    /**\n     * Cancel upload of all FlowFile objects and remove them from the list.\n     * @function\n     */\n    cancel: function () {\n      for (var i = this.files.length - 1; i >= 0; i--) {\n        this.files[i].cancel();\n      }\n    },\n\n    /**\n     * Returns a number between 0 and 1 indicating the current upload progress\n     * of all files.\n     * @function\n     * @returns {number}\n     */\n    progress: function () {\n      var totalDone = 0;\n      var totalSize = 0;\n      // Resume all chunks currently being uploaded\n      each(this.files, function (file) {\n        totalDone += file.progress() * file.size;\n        totalSize += file.size;\n      });\n      return totalSize > 0 ? totalDone / totalSize : 0;\n    },\n\n    /**\n     * Add a HTML5 File object to the list of files.\n     * @function\n     * @param {File} file\n     * @param {Event} [event] event is optional\n     */\n    addFile: function (file, event) {\n      this.addFiles([file], event);\n    },\n\n    /**\n     * Add a HTML5 File object to the list of files.\n     * @function\n     * @param {FileList|Array} fileList\n     * @param {Event} [event] event is optional\n     */\n    addFiles: function (fileList, event) {\n      var files = [];\n      each(fileList, function (file) {\n        // https://github.com/flowjs/flow.js/issues/55\n        if ((!ie10plus || ie10plus && file.size > 0) && !(file.size % 4096 === 0 && (file.name === '.' || file.fileName === '.'))) {\n          var uniqueIdentifier = this.generateUniqueIdentifier(file);\n          if (this.opts.allowDuplicateUploads || !this.getFromUniqueIdentifier(uniqueIdentifier)) {\n            var f = new FlowFile(this, file, uniqueIdentifier);\n            if (this.fire('fileAdded', f, event)) {\n              files.push(f);\n            }\n          }\n        }\n      }, this);\n      if (this.fire('filesAdded', files, event)) {\n        each(files, function (file) {\n          if (this.opts.singleFile && this.files.length > 0) {\n            this.removeFile(this.files[0]);\n          }\n          this.files.push(file);\n        }, this);\n        this.fire('filesSubmitted', files, event);\n      }\n    },\n\n\n    /**\n     * Cancel upload of a specific FlowFile object from the list.\n     * @function\n     * @param {FlowFile} file\n     */\n    removeFile: function (file) {\n      for (var i = this.files.length - 1; i >= 0; i--) {\n        if (this.files[i] === file) {\n          this.files.splice(i, 1);\n          file.abort();\n          this.fire('fileRemoved', file);\n        }\n      }\n    },\n\n    /**\n     * Look up a FlowFile object by its unique identifier.\n     * @function\n     * @param {string} uniqueIdentifier\n     * @returns {boolean|FlowFile} false if file was not found\n     */\n    getFromUniqueIdentifier: function (uniqueIdentifier) {\n      var ret = false;\n      each(this.files, function (file) {\n        if (file.uniqueIdentifier === uniqueIdentifier) {\n          ret = file;\n        }\n      });\n      return ret;\n    },\n\n    /**\n     * Returns the total size of all files in bytes.\n     * @function\n     * @returns {number}\n     */\n    getSize: function () {\n      var totalSize = 0;\n      each(this.files, function (file) {\n        totalSize += file.size;\n      });\n      return totalSize;\n    },\n\n    /**\n     * Returns the total size uploaded of all files in bytes.\n     * @function\n     * @returns {number}\n     */\n    sizeUploaded: function () {\n      var size = 0;\n      each(this.files, function (file) {\n        size += file.sizeUploaded();\n      });\n      return size;\n    },\n\n    /**\n     * Returns remaining time to upload all files in seconds. Accuracy is based on average speed.\n     * If speed is zero, time remaining will be equal to positive infinity `Number.POSITIVE_INFINITY`\n     * @function\n     * @returns {number}\n     */\n    timeRemaining: function () {\n      var sizeDelta = 0;\n      var averageSpeed = 0;\n      each(this.files, function (file) {\n        if (!file.paused && !file.error) {\n          sizeDelta += file.size - file.sizeUploaded();\n          averageSpeed += file.averageSpeed;\n        }\n      });\n      if (sizeDelta && !averageSpeed) {\n        return Number.POSITIVE_INFINITY;\n      }\n      if (!sizeDelta && !averageSpeed) {\n        return 0;\n      }\n      return Math.floor(sizeDelta / averageSpeed);\n    }\n  };\n\n\n\n  /**\n   * Default read function using the webAPI\n   *\n   * @function webAPIFileRead(fileObj, startByte, endByte, fileType, chunk)\n   *\n   */\n  function webAPIFileRead(fileObj, startByte, endByte, fileType, chunk) {\n    var function_name = 'slice';\n\n    if (fileObj.file.slice)\n      function_name =  'slice';\n    else if (fileObj.file.mozSlice)\n      function_name = 'mozSlice';\n    else if (fileObj.file.webkitSlice)\n      function_name = 'webkitSlice';\n\n    chunk.readFinished(fileObj.file[function_name](startByte, endByte, fileType));\n  }\n\n\n  return flowjs.Flow = Flow;\n\n});\ndefine('skylark-flowjs/main',[\r\n\t\"./flowjs\",\r\n\t\"./Flow\"\r\n],function(flowjs){\r\n\treturn flowjs;\r\n});\ndefine('skylark-flowjs', ['skylark-flowjs/main'], function (main) { return main; });\n\n"]}